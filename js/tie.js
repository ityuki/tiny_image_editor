const Tie = (function(){
  const app = this.app = this;
  const modules = app.modules = {};
  const g_window = app.g_window = window;
  const APP_ID = app.APP_ID = "tie";
  const $tie = app.$tie = app;

  const self = this;
  const parent = self.parent = null;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID;
// ================================================
// source: functions.js
// ================================================
const regExpEscape = self.regExpEscape = function regExpEscape(str) {
  return str.replace(/[-\/\\^$*+?.()|\[\]{}]/g, '\\$&');
};

app.modules.utils = {};

const module_utils = self.module_utils = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".utils";
// ================================================
// module: utils , from: fonts.js
// ================================================
// fonts class
// fonts Sample
/*
console.log(Fonts.getFontNames());
*/
const Fonts = self.Fonts = class Fonts {
  static fontlist = [];
  static init = false;
  static fonthash = {};
  static getFontNames() {
    if (!Fonts.init){
      return null;
    }
    const r = [];
    for (let font of Fonts.fontlist){
      r.push(font.name);
    }
    return r;
  }
  static getFontLangs (name){
    if (!Fonts.init){
      return null;
    }
    return Fonts.fonthash[name].lang;
  }
  static {
    window.addEventListener('fontfamily_list-loaded',function(event){
      const fontfamily_list = event.detail;
      Fonts.fontlist = fontfamily_list;
      for (let font of fontfamily_list){
        Fonts.fonthash[font.name] = {
          lang: font.lang,
        };
      }
      Fonts.init = true;
    });
  };
};



// ================================================
// module: utils , from: MTRand.js
// ================================================
// rand class
// MTRand Sample
/*
console.log((new MTRand([0x123, 0x234, 0x345, 0x456])).randN(5));
console.log("1067595299  955945823  477289528 4107218783 4228976476");
*/
const MTRand = self.MTRand = class MTRand {
  constructor(seed){
    this.N = 624;
    this.M = 397;
    this.MATRIX_A = 0x9908b0df;
    this.UPPER_MASK = 0x80000000;
    this.LOWER_MASK = 0x7fffffff;
    this.mt = new Array(this.N);
    this.mti = this.N + 1;
    if (seed !== undefined){
      if (typeof seed === 'number'){
        this.init(seed);
      }else{
        this.init_by_array(seed);
      }
    }
  }
  xor(a,b){
    return ((((a >>> 16) & 0x0000ffff) ^ ((b >>> 16) & 0x0000ffff)) << 16) + ((a & 0x0000ffff) ^ (b & 0x0000ffff)) >>> 0;
  }
  mul(a,b){
    if (a < b){
      const t = a;
      a = b;
      b = t;
    }
    return ((((a >>> 16) & 0x0000ffff) * b) << 16) + ((a & 0x0000ffff) * b) >>> 0;
  }
  init(seed){
    this.seed = seed;
    this.mt[0] = seed >>> 0; // this.mt[0] = seed & 0xffffffff;
    for (this.mti=1; this.mti<this.N; this.mti++) {
      this.mt[this.mti] = (this.mul(1812433253 , (this.xor(this.mt[this.mti-1] , (this.mt[this.mti-1] >>> 30)))) + this.mti);
      this.mt[this.mti] = this.mt[this.mti] >>> 0; //this.mt[this.mti] &= 0xffffffff;
    }
  }
  init_by_array(seeds){
    this.seed = seeds;
    let i, j, k;
    this.init(19650218);
    i=1; j=0;
    k = (this.N>seeds.length ? this.N : seeds.length);
    for (; k; k--) {
      this.mt[i] = (this.xor(this.mt[i] , (this.mul(this.xor(this.mt[i-1] , (this.mt[i-1] >>> 30)) , 1664525)))) + seeds[j] + j;
      this.mt[i] = this.mt[i] >>> 0; // this.mt[i] &= 0xffffffff;
      i++; j++;
      if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
      if (j>=seeds.length) j=0;
    }
    for (k=this.N-1; k; k--) {
      this.mt[i] = (this.xor(this.mt[i] , (this.mul(this.xor(this.mt[i-1] , (this.mt[i-1] >>> 30)) , 1566083941)))) - i;
      this.mt[i] = this.mt[i] >>> 0; // this.mt[i] &= 0xffffffff;
      i++;
      if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
    }
    this.mt[0] = 0x80000000;        
  }
  rand(){
    let y;
    const mag01 = [0x0, this.MATRIX_A];
    if (this.mti >= this.N) {
      let kk;
      if (this.mti == this.N+1) this.init(5489);
      for (kk=0;kk<this.N-this.M;kk++) {
        y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
        this.mt[kk] = this.xor(this.xor(this.mt[kk+this.M] , (y >>> 1)) , mag01[y & 0x1]);
      }
      for (;kk<this.N-1;kk++) {
        y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
        this.mt[kk] = this.xor(this.xor(this.mt[kk+(this.M-this.N)] , (y >>> 1)) , mag01[y & 0x1]);
      }
      y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
      this.mt[this.N-1] = this.xor(this.xor(this.mt[this.M-1] , (y >>> 1)) , mag01[y & 0x1]);
      this.mti = 0;
    }
    y = this.mt[this.mti++];
    y = this.xor(y,(y >>> 11));
    y = this.xor(y,(y << 7) & 0x9d2c5680);
    y = this.xor(y,(y << 15) & 0xefc60000);
    y = this.xor(y,(y >>> 18));
    return y >>> 0;
  }
  randN(count){
    const r = new Array(count);
    for(let i=0;i<count;i++){
      r[i] = this.rand();
    }
    console.log(this)
    return r;
  }
}
const rand_vals = self.rand_vals = function rand_vals(seed,count){
  if (count === undefined || count === null || count <= 0) count = 1;
  console.log(this)
  return (new MTRand(seed)).randN(count);
}

app.modules.utils.vendor = {};

const vendor = self.vendor = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".utils.vendor";
app.modules.utils.vendor.fonts = {};

const fonts = self.fonts = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".utils.vendor.fonts";
// ================================================
// module: utils.vendor.fonts , from: fontfamily_list.js
// ================================================
/**
fontfamily-list

Copyright (c) 2021,2024 Ituki Kirihara/NI

This software is released under the MIT License.
http://opensource.org/licenses/mit-license.php

(Adobe-Blank)
This Font Software is licensed under the SIL Open Font License,
Version 1.1.

This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL

*/

(function(){
  const check_font = async function(){
    const check_font_list = [
      'arial',
      'arial black',
      'arial narrow',
      'arial unicode ms',
      'Century Gothic',
      'Franklin Gothic Medium',
      'Gulim',
      'Dotum',
      'Haettenschweiler',
      'Impact',
      'Ludica Sans Unicode',
      'Microsoft Sans Serif',
      'MS Sans Serif',
      'MV Boil',
      'New Gulim',
      'Tahoma',
      'Trebuchet',
      'Verdana',
      'Noto Sans SC',
      'PingFang SC',
      'Microsoft YaHei',
      'Noto Sans TC',
      'PingFang TC',
      'Microsoft JhengHei',
      'Noto Sans KR',
      'Nanum Gothic',
      'Malgun Gothic',
  
      'Batang',
      'Book Antiqua',
      'Bookman Old Style',
      'Century',
      'Estrangelo Edessa',
      'Garamond',
      'Georgia',
      'Gungsuh',
      'Latha',
      'Mangal',
      'MS Serif',
      'PMingLiU',
      'Palatino Linotype',
      'Raavi',
      'Roman',
      'Shruti',
      'Sylfaen',
      'Times New Roman',
      'Tunga',
      'Noto Serif SC',
      'Kaiti SC',
      'SimSun',
      'Noto Serif TC',
      'Kaiti TC',
      'PMingLiU',
      'Noto Serif KR',
      'Nanum Myeongjo',
      'Batang',
  
      'BatangChe',
      'Courier',
      'Courier New',
      'DotumChe',
      'GlimChe',
      'GungsuhChe',
      'HG行書体',
      'Lucida Console',
      'MingLiU',
      'ＭＳ ゴシック',
      'ＭＳ 明朝',
      'OCRB',
      'SimHei',
      'SimSun',
      'Small Fonts',
      'Terminal',
      
      'alba',
      'alba matter',
      'alba super',
      'baby kruffy',
      'Chick',
      'Croobie',
      'Fat',
      'Freshbot',
      'Frosty',
      'GlooGun',
      'Jokewood',
      'Modern',
      'Monotype Corsiva',
      'Poornut',
      'Pussycat Snickers',
      'Weltron Urban',
  
      'Comic Sans MS',
      'HGP行書体',
      'HG正楷書体-PRO',
      'Jenkins v2.0',
      'Script',
  
      'MS UI Gothic',
      'ＭＳ Ｐゴシック',
      'ＭＳ ゴシック',
      'ＭＳ Ｐ明朝',
      'ＭＳ 明朝',
      'メイリオ',
      'Meiryo UI',
      '游ゴシック',
      '游明朝',
      'ヒラギノ角ゴ Pro W3',
      'ヒラギノ角ゴ ProN W3',
      'ヒラギノ角ゴ Pro W6',
      'ヒラギノ角ゴ ProN W6',
      'ヒラギノ角ゴ Std W8',
      'ヒラギノ角ゴ StdN W8',
      'ヒラギノ丸ゴ Pro W4',
      'ヒラギノ丸ゴ ProN W4',
      'ヒラギノ明朝 Pro W3',
      'ヒラギノ明朝 ProN W3',
      'ヒラギノ明朝 Pro W6',
      'ヒラギノ明朝 ProN W6',
      '游ゴシック体',
      '游明朝体',
      'Osaka',
      'Osaka－等幅',
      'Droid Sans',
      'Roboto',
  
      'Noto Sans JP',
      'Noto Sans CJK JP',
      'Noto Sans CJK',
    ];

    const check_font_list_f = [
      'sans-serif',
      'serif',
      'system-ui',
      'monospace',
      'cursive',
      'fantasy',
    ];
    const check_code = "a";
    const check_codepoint = {
      ja: 'あ',
      zh: '开',
      ko: '아',
      ru: 'Б',
    };
    //while(check_font_list.length>0) check_font_list.pop()
    /*
    if ('query' in navigator.permissions){
      const status = await navigator.permissions.query({ name: "local-fonts" })
      if (status.state === "granted"){
        if('fonts' in navigator){
          const iterableFontObject = navigator.fonts.query();
          for await (const metadata of iterableFontObject) {
            const fontname = metadata.family;
            if (!check_font_list.includes(fontname)) check_font_list.push(fontname);
          }  
        }
      }     
    }
    */
    const f = "Blank";
  
    const style = document.createElement('style');
    document.head.appendChild(style);
    style.sheet.insertRule('@font-face{font-family:' + f + ';src:url("data:font/opentype;base64,T1RUTwAKAIAAAwAgQ0ZGIDTeCDQAACFkAAAZPERTSUcAAAABAABKqAAAAAhPUy8yAF+xmwAAARAAAABgY21hcCRDbtEAAAdcAAAZ6GhlYWQFl9tDAAAArAAAADZoaGVhB1oD7wAAAOQAAAAkaG10eAPoAHwAADqgAAAQBm1heHAIAVAAAAABCAAAAAZuYW1lIE0HkgAAAXAAAAXrcG9zdP+4ADIAACFEAAAAIAABAAAAAQuFfcPHtV8PPPUAAwPoAAAAANFMRfMAAAAA0UxF8wB8/4gDbANwAAAAAwACAAAAAAAAAAEAAANw/4gAAAPoAHwAfANsAAEAAAAAAAAAAAAAAAAAAAACAABQAAgBAAAAAwPoAZAABQAAAooCWAAAAEsCigJYAAABXgAyANwAAAAAAAAAAAAAAAD3/67/+9///w/gAD8AAAAAQURCTwBAAAD//wNw/4gAAANwAHhgLwH/AAAAAAAAAAAAAAAgAAAAAAARANIAAQAAAAAAAQALAAAAAQAAAAAAAgAHAAsAAQAAAAAAAwAbABIAAQAAAAAABAALAAAAAQAAAAAABQA6AC0AAQAAAAAABgAKAGcAAwABBAkAAACUAHEAAwABBAkAAQAWAQUAAwABBAkAAgAOARsAAwABBAkAAwA2ASkAAwABBAkABAAWAQUAAwABBAkABQB0AV8AAwABBAkABgAUAdMAAwABBAkACAA0AecAAwABBAkACwA0AhsAAwABBAkADQKWAk8AAwABBAkADgA0BOVBZG9iZSBCbGFua1JlZ3VsYXIxLjA0NTtBREJPO0Fkb2JlQmxhbms7QURPQkVWZXJzaW9uIDEuMDQ1O1BTIDEuMDQ1O2hvdGNvbnYgMS4wLjgyO21ha2VvdGYubGliMi41LjYzNDA2QWRvYmVCbGFuawBDAG8AcAB5AHIAaQBnAGgAdAAgAKkAIAAyADAAMQAzACwAIAAyADAAMQA1ACAAQQBkAG8AYgBlACAAUwB5AHMAdABlAG0AcwAgAEkAbgBjAG8AcgBwAG8AcgBhAHQAZQBkACAAKABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwApAC4AQQBkAG8AYgBlACAAQgBsAGEAbgBrAFIAZQBnAHUAbABhAHIAMQAuADAANAA1ADsAQQBEAEIATwA7AEEAZABvAGIAZQBCAGwAYQBuAGsAOwBBAEQATwBCAEUAVgBlAHIAcwBpAG8AbgAgADEALgAwADQANQA7AFAAUwAgADEALgAwADQANQA7AGgAbwB0AGMAbwBuAHYAIAAxAC4AMAAuADgAMgA7AG0AYQBrAGUAbwB0AGYALgBsAGkAYgAyAC4ANQAuADYAMwA0ADAANgBBAGQAbwBiAGUAQgBsAGEAbgBrAEEAZABvAGIAZQAgAFMAeQBzAHQAZQBtAHMAIABJAG4AYwBvAHIAcABvAHIAYQB0AGUAZABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwB0AHkAcABlAC8AVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAgAFQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAaQBzACAAZABpAHMAdAByAGkAYgB1AHQAZQBkACAAbwBuACAAYQBuACAAIgBBAFMAIABJAFMAIgAgAEIAQQBTAEkAUwAsACAAVwBJAFQASABPAFUAVAAgAFcAQQBSAFIAQQBOAFQASQBFAFMAIABPAFIAIABDAE8ATgBEAEkAVABJAE8ATgBTACAATwBGACAAQQBOAFkAIABLAEkATgBEACwAIABlAGkAdABoAGUAcgAgAGUAeABwAHIAZQBzAHMAIABvAHIAIABpAG0AcABsAGkAZQBkAC4AIABTAGUAZQAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUAIABmAG8AcgAgAHQAaABlACAAcwBwAGUAYwBpAGYAaQBjACAAbABhAG4AZwB1AGEAZwBlACwAIABwAGUAcgBtAGkAcwBzAGkAbwBuAHMAIABhAG4AZAAgAGwAaQBtAGkAdABhAHQAaQBvAG4AcwAgAGcAbwB2AGUAcgBuAGkAbgBnACAAeQBvAHUAcgAgAHUAcwBlACAAbwBmACAAdABoAGkA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wwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wEAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRAVIBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwIsAi0CLgIvAjACMQIyAjMCNAI1AjYCNwI4AjkCOgI7AjwCPQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoDGwMcAx0DHgMfAyADIQMiAyMDJAMlAyYDJwMoAykDKgMrAywDLQMuAy8DMAMxAzIDMwM0AzUDNgM3AzgDOQM6AzsDPAM9Az4DPwNAA0EDQgNDA0QDRQNGA0cDSANJA0oDSwNMA00DTgNPA1ADUQNSA1MDVANVA1YDVwNYA1kDWgNbA1wDXQNeA18DYANhA2IDYwNkA2UDZgNnA2gDaQNqA2sDbANtA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgN/A4ADgQOCA4MDhAOFA4YDhwOIA4kDigOLA4wDjQOOA48DkAORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwOgA6EDogOjA6QDpQOmA6cDqAOpA6oDqwOsA60DrgOvA7ADsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+A78DwAPBA8IDwwPEA8UDxgPHA8gDyQPKA8sDzAPNA84DzwPQA9ED0gPTA9QD1QPWA9cD2APZA9oD2wPcA90D3gPfA+AD4QPiA+MD5APlA+YD5wPoA+kD6gPrA+wD7QPuA+8D8APxA/ID8wP0A/UD9gP3A/gD+QP6A/sD/AP9A/4D/wQABAEEAgQDBAQEBQQGBAcECAQJBAoECwQMBA0EDgQPBBAEEQQSBBMEFAQVBBYEFwQYBBkEGgQbBBwEHQQeBB8EIAQhBCIEIwQkBCUEJgQnBCgEKQQqBCsELAQtBC4ELwQwBDEEMgQzBDQENQQ2BDcEOAQ5BDoEOwQ8BD0EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE8EUARRBFIEUwRUBFUEVgRXBFgEWQRaBFsEXARdBF4EXwRgBGEEYgRjBGQEZQRmBGcEaARpBGoEawRsBG0EbgRvBHAEcQRyBHMEdAR1BHYEdwR4BHkEegR7BHwEfQR+BH8EgASBBIIEgwSEBIUEhgSHBIgEiQSKBIsEjASNBI4EjwSQBJEEkgSTBJQElQSWBJcEmASZBJoEmwScBJ0EngSfBKAEoQSiBKMEpASlBKYEpwSoBKkEqgSrBKwErQSuBK8EsASxBLIEswS0BLUEtgS3BLgEuQS6BLsEvAS9BL4EvwTABMEEwgTDBMQExQTGBMcEyATJBMoEywTMBM0EzgTPBNAE0QTSBNME1ATVBNYE1wTYBNkE2gTbBNwE3QTeBN8E4AThBOIE4wTkBOUE5gTnBOgE6QTqBOsE7ATtBO4E7wTwBPEE8gTzBPQE9QT2BPcE+AT5BPoE+wT8BP0E/gT/BQAFAQUCBQMFBAUFBQYFBwUIBQkFCgULBQwFDQUOBQ8FEAURBRIFEwUUBRUFFgUXBRgFGQUaBRsFHAUdBR4FHwUgBSEFIgUjBSQFJQUmBScFKAUpBSoFKwUsBS0FLgUvBTAFMQUyBTMFNAU1BTYFNwU4BTkFOgU7BTwFPQU+BT8FQAVBBUIFQwVEBUUFRgVHBUgFSQVKBUsFTAVNBU4FTwVQBVEFUgVTBVQFVQVWBVcFWAVZBVoFWwVcBV0FXgVfBWAFYQViBWMFZAVlBWYFZwVoBWkFagVrBWwFbQVuBW8FcAVxBXIFcwV0BXUFdgV3BXgFeQV6BXsFfAV9BX4FfwWABYEFggWDBYQFhQWGBYcFiAWJBYoFiwWMBY0FjgWPBZAFkQWSBZMFlAWVBZYFlwWYBZkFmgWbBZwFnQWeBZ8FoAWhBaIFowWkBaUFpgWnBagFqQWqBasFrAWtBa4FrwWwBbEFsgWzBbQFtQW2BbcFuAW5BboFuwW8Bb0FvgW/BcAFwQXCBcMFxAXFBcYFxwXIBckFygXLBcwFzQXOBc8F0AXRBdIF0wXUBdUF1gXXBdgF2QXaBdsF3AXdBd4F3wXgBeEF4gXjBeQF5QXmBecF6AXpBeoF6wXsBe0F7gXvBfAF8QXyBfMF9AX1BfYF9wX4BfkF+gX7BfwF/QX+Bf8GAAYBBgIGAwYEBgUGBgYHBggGCQYKBgsGDAYNBg4GDwYQBhEGEgYTBhQGFQYWBhcGGAYZBhoGGwYcBh0GHgYfBiAGIQYiBiMGJAYlBiYGJwYoBikGKgYrBiwGLQYuBi8GMAYxBjIGMwY0BjUGNgY3BjgGOQY6BjsGPAY9Bj4GPwZABkEGQgZDBkQGRQZGBkcGSAZJBkoGSwZMBk0GTgZPBlAGUQZSBlMGVAZVBlYGVwZYBlkGWgZbBlwGXQZeBl8GYAZhBmIGYwZkBmUGZgZnBmgGaQZqBmsGbAZtBm4GbwZwBnEGcgZzBnQGdQZ2BncGeAZ5BnoGewZ8Bn0GfgZ/BoAGgQaCBoMGhAaFBoYGhwaIBokGigaLBowGjQaOBo8GkAaRBpIGkwaUBpUGlgaXBpgGmQaaBpsGnAadBp4GnwagBqEGogajBqQGpQamBqcGqAapBqoGqwasBq0GrgavBrAGsQayBrMGtAa1BrYGtwa4BrkGuga7BrwGvQa+Br8GwAbBBsIGwwbEBsUGxgbHBsgGyQbKBssGzAbNBs4GzwbQBtEG0gbTBtQG1QbWBtcG2AbZBtoG2wbcBt0G3gbfBuAG4QbiBuMG5AblBuYG5wboBukG6gbrBuwG7QbuBu8G8AbxBvIG8wb0BvUG9gb3BvgG+Qb6BvsG/Ab9Bv4G/wcABwEHAgcDBwQHBQcGBwcHCAcJBwoHCwcMBw0HDgcPBxAHEQcSBxMHFAcVBxYHFwcYBxkHGgcbBxwHHQceBx8HIAchByIHIwckByUHJgcnBygHKQcqBysHLActBy4HLwcwBzEHMgczBzQHNQc2BzcHOAc5BzoHOwc8Bz0HPgc/B0AHQQdCB0MHRAdFB0YHRwdIB0kHSgdLB0wHTQdOB08HUAdRB1IHUwdUB1UHVgdXB1gHWQdaB1sHXAddB14HXwdgB2EHYgdjB2QHZQdmB2cHaAdpB2oHawdsB20HbgdvB3AHcQdyB3MHdAd1B3YHdwd4B3kHegd7B3wHfQd+B38HgAeBB4IHgweEB4UHhgeHB4gHiQeKB4sHjAeNB44HjweQB5EHkgeTB5QHlQeWB5cHmAeZB5oHmwecB50HngefB6AHoQeiB6MHpAelB6YHpweoB6kHqgerB6wHrQeuB68HsAexB7IHswe0B7UHtge3B7gHuQe6B7sHvAe9B74HvwfAB8EHwgfDB8QHxQfGB8cHyAfJB8oHywfMB80HzgfPB9AH0QfSB9MH1AfVB9YH1wfYB9kH2gfbB9wH3QfeB98H4AfhB+IH4wfkB+UH5gfnB+gH6QfqB+sH7AftB+4H7wfwB/EH8gfzB/QH9Qf2B/cH+Af5B/oH+wf8B/0H/gf/CAAIAQgCCAMIBAgFCAYIBwgICAkICggLCAwIDQgOCA8IEAgRCBIIEwgUCBUIFggXCBgIGQgaCBsIHAgdCB4IHwggCCEIIggjCCQIJQgmCCcIKAgpCCoIKwgsCC0ILggvCDAIMQgyCDMINAg1CDYINwg4CDkIOgg7CDwIPQg+CD8IQAhBCEIIQwhECEUIRghHCEgISQhKCEsg+wy3+iS3AfcQt/kstwP3EPoEFf58+YT6fAf9WP4nFfnSB/fF/DMFprAV+8X4NwX49gamYhX90gf7xfgzBXBmFffF/DcF/PYGDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OAAEBAQr4HwwmmhwZLRL7joscBUaLBr0KvQv65xUD6AB8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA==");}', 0);
  
    const check_str = async function(fontname,str){
      let escaped_fontname = fontname
      if (!check_font_list_f.includes(fontname)){
        escaped_fontname = '"' + fontname.replace(/"/g, '"') + '"';
      }
      const chkobj = document.createElement('span');
      chkobj.innerHTML = str;
      chkobj.style.height = 0
      chkobj.style.overflow = 'hidden'
      chkobj.style.position = 'absolute'
      chkobj.style.visibility = 'hidden'
      chkobj.style.fontSize = '72px';
      chkobj.style.fontFamily = escaped_fontname + ',' + f;
      document.body.appendChild(chkobj);
      return await document.fonts.load("72px '" + fontname + "','" + f + "'")
      .then(function (fontset){
        var ok = chkobj.offsetWidth > 1;
        document.body.removeChild(chkobj);
        return ok;
      }).catch(function (err){
        document.body.removeChild(chkobj);
        return false;
      })
    };
    const check = async function(name) {
      if (await check_str(name,check_code)){
        const ret = { name, lang: {} };
        for (let lang of Object.keys(check_codepoint)) {
          ret.lang[lang] = false;
          if (await check_str(name,check_codepoint[lang])) {
            ret.lang[lang] = true;
          }
        }
        return ret;
      } else {
        return null;
      }
    };
    const ret = [];
    const target = check_font_list.concat(check_font_list_f);
    for (let fontname of target) {
      const d = await check(fontname);
      if (d) ret.push(d);
    }
    document.head.removeChild(style);
    var ev = new CustomEvent('fontfamily_list-loaded', {detail: ret});
    window.dispatchEvent(ev);
  }
  document.addEventListener('DOMContentLoaded',function(){
    check_font();
  });
})();



Object.assign(app.modules.utils.vendor.fonts,self);

return self;
}).call({},self);

Object.assign(app.modules.utils.vendor,self);

return self;
}).call({},self);

Object.assign(app.modules.utils,self);

return self;
}).call({},self);

app.modules.browser = {};

const module_browser = self.module_browser = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser";
app.modules.browser.layer = {};

const layer = self.layer = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser.layer";
// ================================================
// module: browser.layer , from: 00_baseLayer.js
// ================================================
const BaseLayer = self.BaseLayer = class BaseLayer {
  static currentLayerId = 0;
  constructor(main) {
    BaseLayer.currentLayerId++;
    this.id = BaseLayer.currentLayerId;
    this.main = main;
    this.aboveLayers = [];
    this.belowLayers = [];
    this.position = { x: 0, y: 0 };
    this.size = { width: 0, height: 0 };
  }
  addAboveLayer(layer) {
    this.aboveLayers.push(layer);
  }
  addBelowLayer(layer) {
    this.belowLayers.push(layer);
  }
  removeAboveLayer(layer) {
    this.aboveLayers = this.aboveLayers.filter(l => l !== layer);
  }
  removeBelowLayer(layer) {
    this.belowLayers = this.belowLayers.filter(l => l !== layer);
  }
  getTopLayers() {
    let topLayers = [];
    if (this.aboveLayers.length === 0) {
      topLayers.push(this);
      return topLayers;
    }
    for (let layer of this.aboveLayers) {
      if (layer instanceof BaseLayer) {
        topLayers = topLayers.concat(layer.getTopLayers());
      } else {
        // DO NOTHING
      }
    }
    return topLayers;
  }
  outputToCanvas(canvas) {
  }
  outputBelowLayers(canvas) {
    for (let layer of this.belowLayers) {
      if (layer instanceof BaseLayer) {
        layer.outputToCanvas(canvas);
      } else {
        // DO NOTHING
      }
    }
  }
  outputCurrentLayer(canvas) {
    this.outputBelowLayers(canvas);
    this.outputToCanvas(canvas);
  }
}


Object.assign(app.modules.browser.layer,self);

return self;
}).call({},self);
// ================================================
// module: browser , from: canvas.js
// ================================================
const Canvas = self.Canvas = class Canvas {
  static OverlapType = {
    SourceOver:"source-over",
    SourceIn:"source-in",
    SourceOut:"source-out",
    SourceAtop:"source-atop",
    DestinationOver:"destination-over",
    DestinationIn:"destination-in",
    DestinationOut:"destination-out",
    DestinationAtop:"destination-atop",
    Lighter:"lighter",
    Copy:"copy",
    Xor:"xor",
    Multiply:"multiply",
    Screen:"screen",
    Overlay:"overlay",
    Darken:"darken",
    Lighten:"lighten",
    ColorDodge:"color-dodge",
    ColorBurn:"color-burn",
    HardLight:"hard-light",
    SoftLight:"soft-light",
    Difference:"difference",
    Exclusion:"exclusion",
    Hue:"hue",
    Saturation:"saturation",
    Color:"color",
    Luminosity:"luminosity",
  };
  static ResizeType = {
    Center:"center",
    TopLeft:"top-left",
    TopRight:"top-right",
    BottomLeft:"bottom-left",
    BottomRight:"bottom-right",
  };
  static ScalingType = {
    None:"none",
    Smoothing:"smoothing",
    Nearest:"nearest",
    Bilinear:"bilinear",
    Bicubic:"bicubic",
  };
  

  static currentCanvasId = 0;
  constructor(main, width, height) {
    this.main = main;
    Canvas.currentCanvasId += 1;
    this.id = Canvas.currentCanvasId;
    this.raw = this.main.window.document.createElement('canvas');
    this.raw.id = `tie_${this.main.tieName}_canvas_${this.id}`;
    this.raw.width = width;
    this.raw.height = height;
    this.drawOverlapType = Canvas.OverlapType.SourceOver;
    this.drawAlpha = 1;
    this.resizeType = Canvas.ResizeType.TopLeft;
    this.scalingType = Canvas.ScalingType.Smoothing;
  }
  getRawCanvas(canvas){
    if (canvas instanceof Canvas){
      canvas = canvas.raw;
    }else if (canvas instanceof HTMLCanvasElement){
      canvas = canvas;
    }else{
      return null;
    }
    return canvas;
  }
  rcopyRect(destCanvas,w,h,sx,sy,dx,dy){
    destCanvas = this.getRawCanvas(destCanvas);
    if (destCanvas === null){
      return false;
    }
    if (w === undefined){
      w = this.raw.width;
    }
    if (h === undefined){
      h = this.raw.height;
    }
    if (sx === undefined){
      sx = 0;
    }
    if (sy === undefined){
      sy = 0;
    }
    if (dx === undefined){
      dx = sx;
    }
    if (dy === undefined){
      dy = sy;
    }
    const srcContext = this.raw.getContext('2d');
    const destContext = destCanvas.getContext('2d');
    const srcimg = srcContext.getImageData(sx,sy,w,h);
    destContext.putImageData(srcimg,dx,dy,0,0,w,h);
  }
  rcopy(destCanvas){
    this.rcopyRect(destCanvas);
  }
  copyRect(srcCanvas,w,h,sx,sy,dx,dy){
    srcCanvas = this.getRawCanvas(srcCanvas);
    if (srcCanvas === null){
      return false;
    }
    if (w === undefined){
      w = srcCanvas.width;
    }
    if (h === undefined){
      h = srcCanvas.height;
    }
    if (sx === undefined){
      sx = 0;
    }
    if (sy === undefined){
      sy = 0;
    }
    if (dx === undefined){
      dx = sx;
    }
    if (dy === undefined){
      dy = sy;
    }
    const srcContext = srcCanvas.getContext('2d');
    const destContext = this.raw.getContext('2d');
    const srcimg = srcContext.getImageData(sx,sy,w,h);
    destContext.putImageData(srcimg,dx,dy);
  }
  copy(srcCanvas){
    this.copyRect(srcCanvas);
  }
  fillRect(x,y,w,h,color){
    if (x === undefined){
      x = 0;
    }
    if (y === undefined){
      y = 0;
    }
    if (w === undefined){
      w = this.raw.width;
    }
    if (h === undefined){
      h = this.raw.height;
    }
    const colorAry = Color.colorToArray(color);
    const context = this.raw.getContext('2d');
    const contextimg = context.getImageData(x,y,w,h);
    for(let i = 0; i < contextimg.data.length; i += 4){
      contextimg.data[i] = colorAry[0];
      contextimg.data[i + 1] = colorAry[1];
      contextimg.data[i + 2] = colorAry[2];
      contextimg.data[i + 3] = colorAry[3];
    }
    context.putImageData(contextimg,x,y);
  }
  fill(color){
    this.fillRect(0,0,this.raw.width,this.raw.height,color);
  }
  drawRect(canvas,sx,sy,sw,sh,dx,dy,dw,dh){
    canvas = this.getRawCanvas(canvas);
    if (canvas === null){
      return false;
    }
    if (sx === undefined){
      sx = 0;
    }
    if (sy === undefined){
      sy = 0;
    }
    if (sw === undefined){
      sw = this.raw.width;
    }
    if (sh === undefined){
      sh = this.raw.height;
    }
    if (dx === undefined){
      dx = sx;
    }
    if (dy === undefined){
      dy = sy;
    }
    if (dw === undefined){
      dw = sw;
    }
    if (dh === undefined){
      dh = sh;
    }
    const scontext = this.raw.getContext('2d');
    scontext.globalAlpha = this.drawAlpha;
    scontext.globalCompositeOperation = this.drawOverlapType;
    scontext.drawImage(canvas,sx,sy,sw,sh,dx,dy,dw,dh);
    return true;
  }
  draw(canvas,dx,dy){
    return this.drawRect(canvas,0,0,this.raw.width,this.raw.height,dx,dy,this.raw.width,this.raw.height);
  }
  getRect(){
    return {
      x: 0,
      y: 0,
      w: this.raw.w,
      h: this.raw.h,
    };
  }
  setResizeType(type){
    this.resizeType = type;
  }
  resize(width,height){
    const tcanvas = this.main.window.document.createElement('canvas');
    tcanvas.width = this.raw.width;
    tcanvas.height = this.raw.height;
    this.rcopy(tcanvas);
    this.raw.width = width;
    this.raw.height = height;
    let x = 0;
    let y = 0;
    if (this.resizeType === Canvas.ResizeType.Center){
      x = (width - tcanvas.width) / 2;
      y = (height - tcanvas.height) / 2;
    }else if (this.resizeType === Canvas.ResizeType.TopLeft){
      // DO NOTHING
    }else if (this.resizeType === Canvas.ResizeType.TopRight){
      x = width - tcanvas.width;
    }else if (this.resizeType === Canvas.ResizeType.BottomLeft){
      y = height - tcanvas.height;
    }else if (this.resizeType === Canvas.ResizeType.BottomRight){
      x = width - tcanvas.width;
      y = height - tcanvas.height;
    }else{
      return false;
    }
    this.copyRect(tcanvas,tcanvas.width,tcanvas.height,0,0,x,y);
    return true;
  }
  setScalingType(type){
    this.scalingType = type;
  }
  scaling(width,height){
    if (width === this.raw.width && height === this.raw.height){
      return true;
    }
    const tcanvas = this.main.window.document.createElement('canvas');
    tcanvas.width = this.raw.width;
    tcanvas.height = this.raw.height;
    this.rcopy(tcanvas);
    const tcontext = tcanvas.getContext('2d');
    this.raw.width = width;
    this.raw.height = height;
    this.fill([255,255,255,0])
    const context = this.raw.getContext('2d');
    const simg = tcontext.getImageData(0,0,tcanvas.width,tcanvas.height);
    const dimg = context.getImageData(0,0,this.raw.width,this.raw.height);
    const wscale = this.raw.width / tcanvas.width;
    const hscale = this.raw.height / tcanvas.height;
    const invWscale = 1 / wscale;
    const invHscale = 1 / hscale;
    const addrXY = (cv,x,y) => {
      return (y * cv.width + x) * 4;
    }
    if (this.scalingType === Canvas.ScalingType.None){
      context.imageSmoothingEnabled = false;
      context.globalAlpha = 1;
      context.globalCompositeOperation = Canvas.OverlapType.SourceOver;
      context.drawImage(tcanvas,0,0,tcanvas.width,tcanvas.height,0,0,this.raw.width,this.raw.height);
    }else if (this.scalingType === Canvas.ScalingType.Smoothing){
      context.imageSmoothingEnabled = true;
      context.globalAlpha = 1;
      context.globalCompositeOperation = Canvas.OverlapType.SourceOver;
      context.drawImage(tcanvas,0,0,tcanvas.width,tcanvas.height,0,0,this.raw.width,this.raw.height);
    }else if (this.scalingType === Canvas.ScalingType.Nearest){
      for(let y = 0; y < this.raw.height; y++){
        for(let x = 0; x < this.raw.width; x++){
          let cx0 = Math.floor((x / wscale) + 0.5);
          let cy0 = Math.floor((y / hscale) + 0.5);
          if (cx0 < 0){
            cx0 = 0;
          }
          if (cy0 < 0){
            cy0 = 0;
          }
          if (cx0 >= tcanvas.width){
            cx0 = tcanvas.width - 1;
          }
          if (cy0 >= tcanvas.height){
            cy0 = tcanvas.height - 1;
          }
          const index = (cy0 * tcanvas.width + cx0) * 4;
          const dindex = (y * this.raw.width + x) * 4;
          dimg.data[dindex] = simg.data[index];
          dimg.data[dindex + 1] = simg.data[index + 1];
          dimg.data[dindex + 2] = simg.data[index + 2];
          dimg.data[dindex + 3] = simg.data[index + 3];
        }
      }
      context.putImageData(dimg,0,0);
    }else if (this.scalingType === Canvas.ScalingType.Bilinear){
      // https://github.com/rgba-image/bilinear/blob/master/src/index.ts (MIT License)
      const inerpolate = (k, kMin,vMin,kMax,vMax) => {
        return (kMin == kMax) ? vMin : Math.round( ( k - kMin ) * vMax + ( kMax - k ) * vMin );
      }
      const assign = (destIndex,sx,xMin,xMax,y,yMin,yMax) => {
        let minIndex = addrXY(tcanvas,xMin,yMin);
        let maxIndex = addrXY(tcanvas,xMax,yMin);
        const vMin0 = inerpolate(sx,xMin,simg.data[minIndex],xMax,simg.data[maxIndex]);
        const vMin1 = inerpolate(sx,xMin,simg.data[minIndex + 1],xMax,simg.data[maxIndex + 1]);
        const vMin2 = inerpolate(sx,xMin,simg.data[minIndex + 2],xMax,simg.data[maxIndex + 2]);
        const vMin3 = inerpolate(sx,xMin,simg.data[minIndex + 3],xMax,simg.data[maxIndex + 3]);
        if (yMax == yMin){
          dimg.data[destIndex+0] = vMin0;
          dimg.data[destIndex+1] = vMin1;
          dimg.data[destIndex+2] = vMin2;
          dimg.data[destIndex+3] = vMin3;
        }else{
          minIndex = addrXY(tcanvas,xMin,yMax);
          maxIndex = addrXY(tcanvas,xMax,yMax);
          const vMax0 = inerpolate(sx,xMin,simg.data[minIndex],xMax,simg.data[maxIndex]);
          const vMax1 = inerpolate(sx,xMin,simg.data[minIndex + 1],xMax,simg.data[maxIndex + 1]);
          const vMax2 = inerpolate(sx,xMin,simg.data[minIndex + 2],xMax,simg.data[maxIndex + 2]);
          const vMax3 = inerpolate(sx,xMin,simg.data[minIndex + 3],xMax,simg.data[maxIndex + 3]);
          dimg.data[destIndex+0] = inerpolate(y,yMin,vMin0,yMax,vMax0);
          dimg.data[destIndex+1] = inerpolate(y,yMin,vMin1,yMax,vMax1);
          dimg.data[destIndex+2] = inerpolate(y,yMin,vMin2,yMax,vMax2);
          dimg.data[destIndex+3] = inerpolate(y,yMin,vMin3,yMax,vMax3);
        }
      }
      for(let y = 0; y < this.raw.height; y++){
        const srcY = y * invHscale;
        const yMin = srcY < 0 ? 0 : Math.trunc(srcY);
        const yMax = Math.min(Math.ceil(srcY),tcanvas.height - 1);
        for(let x = 0; x < this.raw.width; x++){
          const srcX = x * invWscale;
          const xMin = srcX < 0 ? 0 : Math.trunc(srcX);
          const xMax = Math.min(Math.ceil(srcX),tcanvas.width - 1);
          const addr = addrXY(this.raw,x,y);
          assign(addr,srcX,xMin,xMax,srcY,yMin,yMax);
        }
      }
      context.putImageData(dimg,0,0);
    }else if (this.scalingType === Canvas.ScalingType.Bicubic){
      // https://www.rainorshine.asia/2013/04/03/post2351.html
      const bicubicWeight = (d) => {
        if (d < 1){
          return 1 - 2 * d * d + d * d * d;
        }else if (d < 2){
          return 4 - 8 * d + 5 * d * d - d * d * d;
        }else{
          return 0;
        }
      }
      const trimByte = (v) => {
        return Math.min(255,Math.max(0,Math.round(v)));
      }
      for(let iy = 0; iy < this.raw.height; iy++){
        for(let ix = 0; ix < this.raw.width; ix++){
          const wfx = invWscale * ix;
          const wfy = invHscale * iy;
          const x = Math.trunc(wfx);
          const y = Math.trunc(wfy);
          let r = 0;
          let g = 0;
          let b = 0;
          let a = 0;
          for(let jy = y - 1; jy <= y + 2; jy++){
            for(let jx = x - 1; jx <= x + 2; jx++){
              const w = bicubicWeight(Math.abs(wfx - jx)) * bicubicWeight(Math.abs(wfy - jy));
              if (w === 0){
                continue;
              }
              let sx = (jx > tcanvas.width-1) ? x: jx;
              let sy = (jy > tcanvas.height-1) ? y: jy;
              sx = (sx < 0) ? 0: sx;
              sy = (sy < 0) ? 0: sy;
              const addr = addrXY(tcanvas,sx,sy);
              r += simg.data[addr] * w;
              g += simg.data[addr + 1] * w;
              b += simg.data[addr + 2] * w;
              a += simg.data[addr + 3] * w;
            }
          }
          const addr = addrXY(this.raw,ix,iy);
          dimg.data[addr] = trimByte(r);
          dimg.data[addr + 1] = trimByte(g);
          dimg.data[addr + 2] = trimByte(b);
          dimg.data[addr + 3] = trimByte(a);
        }
      }
      context.putImageData(dimg,0,0);
    }else{
      return false;
    }
    return true;
  }
  rateScaling(rate){
    return this.scaling(this.raw.width * rate,this.raw.height * rate);
  }
  move(x,y){
    if (x === 0 && y === 0){
      return true;
    }
    if (this.raw.width + x <= 0 || this.raw.height + y <= 0){
      this.raw.width = 1;
      this.raw.height = 1;
      this.fill([255,255,255,0]);
      return true;
    }
    const tcanvas = this.main.window.document.createElement('canvas');
    tcanvas.width = this.raw.width;
    tcanvas.height = this.raw.height;
    this.rcopy(tcanvas);
    this.raw.width = tcanvas.width+x;
    this.raw.height = tcanvas.height+y;
    this.copyRect(tcanvas,tcanvas.width,tcanvas.height,0,0,x,y);
  }
  rotate(centerX,centerY,angle){
    const tcanvas = this.main.window.document.createElement('canvas');
    tcanvas.width = this.raw.width;
    tcanvas.height = this.raw.height;
    this.rcopy(tcanvas);
    this.raw.width = tcanvas.width;
    this.raw.height = tcanvas.height;
    const context = this.raw.getContext('2d');
    context.translate(centerX,centerY);
    context.rotate(angle * Math.PI / 180);
    context.drawImage(tcanvas,-centerX,-centerY);
  }
  rotateCenter(angle){
    return this.rotate(this.raw.width / 2,this.raw.height / 2,angle);
  }
  flipHorizontal(){
    const tcanvas = this.main.window.document.createElement('canvas');
    tcanvas.width = this.raw.width;
    tcanvas.height = this.raw.height;
    this.rcopy(tcanvas);
    this.raw.width = tcanvas.width;
    this.raw.height = tcanvas.height;
    const context = this.raw.getContext('2d');
    context.scale(-1,1);
    context.drawImage(tcanvas,-tcanvas.width,0);
  }
  flipVertical(){
    const tcanvas = this.main.window.document.createElement('canvas');
    tcanvas.width = this.raw.width;
    tcanvas.height = this.raw.height;
    this.rcopy(tcanvas);
    this.raw.width = tcanvas.width;
    this.raw.height = tcanvas.height;
    const context = this.raw.getContext('2d');
    context.scale(1,-1);
    context.drawImage(tcanvas,0,-tcanvas.height);
  }
  colorFilter(filter){
    const context = this.raw.getContext('2d');
    const img = context.getImageData(0,0,this.raw.width,this.raw.height);
    for(let i = 0; i < img.data.length; i += 4){
      const color = filter([img.data[i],img.data[i + 1],img.data[i + 2],img.data[i + 3]]);
      img.data[i] = color[0];
      img.data[i + 1] = color[1];
      img.data[i + 2] = color[2];
      img.data[i + 3] = color[3];
    }
    context.putImageData(img,0,0);
  }
  colorFilterGray(){
    this.colorFilter((color) => {
      const gray = 0.299 * color[0] + 0.587 * color[1] + 0.114 * color[2];
      return [gray,gray,gray,color[3]];
    });
  }
  colorFilterSepia(){
    this.colorFilter((color) => {
      const r = 0.393 * color[0] + 0.769 * color[1] + 0.189 * color[2];
      const g = 0.349 * color[0] + 0.686 * color[1] + 0.168 * color[2];
      const b = 0.272 * color[0] + 0.534 * color[1] + 0.131 * color[2];
      return [r,g,b,color[3]];
    });
  }
  getBlurHash(){
    const canvas = this.main.window.document.createElement('canvas');
    const context = canvas.getContext('2d');
    const scale = 100 / Math.max(this.raw.width, this.raw.height);
    canvas.width = Math.round(this.raw.width * scale);
    canvas.height = Math.round(this.raw.height * scale);
    context.drawImage(this.raw, 0, 0, canvas.width, canvas.height);
    const pixels = context.getImageData(0, 0, canvas.width, canvas.height);
    return self.vendor.blurhash.encode(pixels.data,pixels.width,pixels.height,4,3);
  }
  setBlurHash(hash){
    const w = this.raw.width;
    const h = this.raw.height;
    const scale = 100 / Math.max(this.raw.width, this.raw.height);
    this.raw.width = Math.round(this.raw.width * scale);
    this.raw.height = Math.round(this.raw.height * scale);
    const imgd = self.vendor.blurhash.decode(hash,this.raw.width,this.raw.height,1);
    const context = this.raw.getContext('2d');
    const pixels = context.getImageData(0, 0, this.raw.width, this.raw.height);
    for(let i = 0; i < imgd.length; i ++){
      pixels.data[i] = imgd[i];
    }
    context.putImageData(pixels,0,0);
    this.scaling(w,h);
  }
  getThumbHash(){
    const canvas = this.main.window.document.createElement('canvas');
    const context = canvas.getContext('2d');
    const scale = 100 / Math.max(this.raw.width, this.raw.height);
    canvas.width = Math.round(this.raw.width * scale);
    canvas.height = Math.round(this.raw.height * scale);
    context.drawImage(this.raw, 0, 0, canvas.width, canvas.height);
    const pixels = context.getImageData(0, 0, canvas.width, canvas.height);
    const binaryThumbHash = self.vendor.ThumbHash.rgbaToThumbHash(pixels.width, pixels.height, pixels.data);
    const binaryToBase64 = binary => btoa(String.fromCharCode(...binary))
    return binaryToBase64(binaryThumbHash);
  }
  setThumbHash(hash){
    const w = this.raw.width;
    const h = this.raw.height;
    const base64ToBinary = base64 => new Uint8Array(atob(base64).split('').map(x => x.charCodeAt(0)))
    const imgd = self.vendor.ThumbHash.thumbHashToRGBA(base64ToBinary(hash));
    this.raw.width = imgd.w;
    this.raw.height = imgd.h;
    const context = this.raw.getContext('2d');
    const pixels = context.getImageData(0, 0, this.raw.width, this.raw.height);
    for(let i = 0; i < imgd.rgba.length; i ++){
      pixels.data[i] = imgd.rgba[i];
    }
    context.putImageData(pixels, 0, 0);
    this.scaling(w,h);
  }
  loadLocalImage(){
    const input = this.main.window.document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e) => {
      let file = null;
      if (e.target.files){
        file = e.target.files[0];
      }else if (e.dataTransfer.files){
        file = e.dataTransfer.files[0];
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const context = this.raw.getContext('2d');
          this.raw.width = img.width;
          this.raw.height = img.height;
          context.globalAlpha = 1;
          context.globalCompositeOperation = Layer.OverlapType.Copy;
          context.drawImage(img,0,0);
        };
        img.onerror = () => {
          alert('ERROR\nnot image file')
        }
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    };
    input.click();
  }
}

// ================================================
// module: browser , from: clipcache.js
// ================================================

// ================================================
// module: browser , from: color.js
// ================================================
const Color = self.Color = class Color {
  static colorToArray(color, defaultColor){
    if (defaultColor === null || defaultColor === undefined){
      defaultColor = [255,255,255,0];
    }
    if (color === null || color === undefined){
      return defaultColor;
    }else if (color instanceof Array){
      if (color.length == 3){
        color.push(1);
      }
      return color.map((v) => parseInt(v));
    }else if (typeof color === 'string'){
      if (color.startsWith('rgba(')){
        color = color.replace('rgba(','').replace(')','');
      }else if (color.startsWith('rgb(')){
        color = color.replace('rgb(','').replace(')',',1');
      }else{
        return defaultColor;
      }
      const c = color.split(',');
      if (c.length == 3){
        c.push(1);
      }
      return c.map((v) => parseInt(v));
    }else{
      return defaultColor;
    }
  }
}

// ================================================
// module: browser , from: layer.js
// ================================================
const Layer = self.Layer = class Layer {
  static OverlapType = {
    SourceOver:"source-over",
    SourceIn:"source-in",
    SourceOut:"source-out",
    SourceAtop:"source-atop",
    DestinationOver:"destination-over",
    DestinationIn:"destination-in",
    DestinationOut:"destination-out",
    DestinationAtop:"destination-atop",
    Lighter:"lighter",
    Copy:"copy",
    Xor:"xor",
    Multiply:"multiply",
    Screen:"screen",
    Overlay:"overlay",
    Darken:"darken",
    Lighten:"lighten",
    ColorDodge:"color-dodge",
    ColorBurn:"color-burn",
    HardLight:"hard-light",
    SoftLight:"soft-light",
    Difference:"difference",
    Exclusion:"exclusion",
    Hue:"hue",
    Saturation:"saturation",
    Color:"color",
    Luminosity:"luminosity",
  };

  static LinkedLayerType = {
    Window: 'window',
    Size: 'size',
    Pos: 'pos',
    Move: 'move',
    CanvasSize: 'canvasSize',
  };

  static DoMethodType = {
    Execute: 0,
    FileLoad: 1,
    CanvasPosChange: 2,
    CanvasSizeChange: 3,
    CanvasAlphaChange: 4,
    CanvasOverlapChange: 5,
    OutputPosChange: 6,
    OutputSizeChange: 7,
    OutputAlphaChange: 8,
    OutputOverlapChange: 9,
  };

  static layerId = 0;

  constructor(main, copyFromLayer){
    this.main = main;
    Layer.layerId += 1;
    this.id = Layer.layerId;
    let x = 0;
    let y = 0;
    let w = this.main.defaultLayer.width;
    let h = this.main.defaultLayer.height;
    if (copyFromLayer != null){
      x = copyFromLayer.canvas.x;
      y = copyFromLayer.canvas.y;
      w = copyFromLayer.canvas.w;
      h = copyFromLayer.canvas.h;
    }
    this.canvasOpt = {
      x: x,
      y: y,
      w: w,
      h: h,
      alpha: 1,
      overlap: Layer.OverlapType.SourceOver,
    };
    let ox = 0;
    let oy = 0;
    let ow = this.main.defaultLayer.width;
    let oh = this.main.defaultLayer.height;
    if (copyFromLayer != null){
      ox = copyFromLayer.outputRect.x;
      oy = copyFromLayer.outputRect.y;
      ow = copyFromLayer.outputRect.w;
      oh = copyFromLayer.outputRect.h;
    }
    this.outputOpt = {
      x: ox,
      y: oy,
      w: ow,
      h: oh,
      alpha: 1,
      overlap: Layer.OverlapType.SourceOver,
    };
    this.canvasCacheRect = {
      x: 0,
      y: 0,
      w: 0,
      h: 0,
    }
    this.parentLayers = [];
    this.childLayers = [];
    this.linkedLayers = {
      window: [],
      size: [],
      pos: [],
      move: [],
      canvasSize: [],
    }
    this.defaultExternalColor = [255,255,255,0]
    this.history = [];
    this.historyPos = -1;
    this.historyMax = -1;
    this.updated = false;
    this.canvasUpdated = false;
    this.canvasCacheUpdated = false;
    this.canvasObj = this.main.window.document.createElement('canvas');
    this.canvasObj.id = 'tie_' + this.main.tieName + '_layer_' + this.id + '_canvas';
    this.canvasObj.width = this.canvasOpt.w;
    this.canvasObj.height = this.canvasOpt.h;
    this.canvasBackupObj = this.main.window.document.createElement('canvas');
    this.canvasBackupObj.id = 'tie_' + this.main.tieName + '_layer_' + this.id + '_canvasBackup';
    this.canvasCacheObj = this.main.window.document.createElement('canvas');
    this.canvasCacheObj.id = 'tie_' + this.main.tieName + '_layer_' + this.id + '_canvasCache';
    this.fill(this.canvasObj,[255,255,255,0]);
  }
  addParentLayer(layer){
    this.parentLayers.push(layer);
    this.updated = true;
  }
  removeParentLayer(layer){
    this.parentLayers = this.parentLayers.filter((v) => v !== layer);
    this.updated = true;
  }
  addChildLayer(layer){
    this.childLayers.push(layer);
    this.updated = true;
  }
  removeChildLayer(layer){
    this.childLayers = this.childLayers.filter((v) => v !== layer);
    this.updated = true;
  }
  addLinkedLayer(layer, type){
    if (type === Layer.LinkedLayerType.Window){
      this.linkedLayers.window.push(layer);
    }else if (type === Layer.LinkedLayerType.Size){
      this.linkedLayers.size.push(layer);
    }else if (type === Layer.LinkedLayerType.Pos){
      this.linkedLayers.pos.push(layer);
    }else if (type === Layer.LinkedLayerType.Move){
      this.linkedLayers.move.push(layer);
    }else if (type === Layer.LinkedLayerType.CanvasSize){
      this.linkedLayers.canvasSize.push(layer);
    }
  }
  removeLinkedLayer(layer, type){
    if (type === Layer.LinkedLayerType.Window){
      this.linkedLayers.window = this.linkedLayers.window.filter((v) => v !== layer);
    }else if (type === Layer.LinkedLayerType.Size){
      this.linkedLayers.size = this.linkedLayers.size.filter((v) => v !== layer);
    }else if (type === Layer.LinkedLayerType.Pos){
      this.linkedLayers.pos = this.linkedLayers.pos.filter((v) => v !== layer);
    }else if (type === Layer.LinkedLayerType.Move){
      this.linkedLayers.move = this.linkedLayers.move.filter((v) => v !== layer);
    }else if (type === Layer.LinkedLayerType.CanvasSize){
      this.linkedLayers.canvasSize = this.linkedLayers.canvasSize.filter((v) => v !== layer);
    }
  }
  setExternalColor(color){
    this.defaultExternalColor = color;
    this.updated = true;
  }
  getExternalColor(){
    return this.defaultExternalColor;
  }
  loadLocalImage(){
    const input = this.main.window.document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e) => {
      let file = null;
      if (e.target.files){
        file = e.target.files[0];
      }else if (e.dataTransfer.files){
        file = e.dataTransfer.files[0];
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const context = this.canvasObj.getContext('2d');
          const h = {
            type: Layer.DoMethodType.FileLoad,
            image: structuredClone(context.getImageData(0,0,this.canvasObj.width,this.canvasObj.height).data),
            size:{
              w: this.canvasObj.width,
              h: this.canvasObj.height,
            },
            loadFile: file,
            loadImage: null,
            loadSize:{
              w: img.width,
              h: img.height,
            },
          };
          this.canvasObj.width = img.width;
          this.canvasObj.height = img.height;
          this.canvasOpt.w = img.width;
          this.canvasOpt.h = img.height;
          const ga = context.globalAlpha;
          const gcom = context.globalCompositeOperation;
          context.globalAlpha = 1;
          context.globalCompositeOperation = Layer.OverlapType.Copy;
          context.drawImage(img,0,0);
          context.globalAlpha = ga;
          context.globalCompositeOperation = gcom;
          h.loadImage = structuredClone(context.getImageData(0,0,this.canvasObj.width,this.canvasObj.height).data);
          this.pushHistory(h);
          this.updated = true;
          this.canvasUpdated = true;
          this.doWrite();
        };
        img.onerror = () => {
          alert('ERROR\nnot image file')
        }
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    };
    input.click();
  }
  pushHistory(h){
    if (this.historyMax != 0){
      this.history.push(h);
    }
    while (this.historyPos >= 0 && this.historyPop >= this.history.length - 1){
      this.historyPop();
    }
    this.historyPos = this.history.length - 1;  
    if (this.historyMax >= 0){
      while (this.history.length > this.historyMax){
        this.historyUnshift();
      }
    }
  }
  colorRGBA2Array(color){
    if (color === null || color === undefined){
      return [255,255,255,0];
    }else if (color instanceof Array){
      if (color.length == 3){
        color.push(1);
      }
      return color.map((v) => parseInt(v));
    }else if (typeof color === 'string'){
      if (color.startsWith('rgba(')){
        color = color.replace('rgba(','').replace(')','');
      }else if (color.startsWith('rgb(')){
        color = color.replace('rgb(','').replace(')',',1');
      }else{
        return [255,255,255,0];
      }
      const c = color.split(',');
      if (c.length == 3){
        c.push(1);
      }
      return c.map((v) => parseInt(v));
    }else{
      return [255,255,255,0];
    }
  }
  fillRect(canvas,x,y,w,h,color){
    const context = canvas.getContext('2d');
    const cary = this.colorRGBA2Array(color);
    const contextimg = context.getImageData(x,y,w,h);
    for(let i = 0; i < contextimg.data.length; i += 4){
      contextimg.data[i] = cary[0];
      contextimg.data[i + 1] = cary[1];
      contextimg.data[i + 2] = cary[2];
      contextimg.data[i + 3] = cary[3];
    }
    context.putImageData(contextimg,x,y);
  }
  fill(canvas,color){
    this.fillRect(canvas,0,0,canvas.width,canvas.height,color);
  }
  setCanvasPos(x,y,callers){
    const crect = this.getCanvasRect();
    if (crect.x == x && crect.y == y){
      return;
    }
    let nextcallers = [];
    if (callers !== null && callers !== undefined){
      if (callers.indexOf(this.id) >= 0){
        return;
      }
      nextcallers = structuredClone(callers);
    }
    nextcallers.push(this.id);
    this.pushHistory({
      type: Layer.DoMethodType.CanvasPosChange,
      pos:{
        x: this.canvasOpt.x,
        y: this.canvasOpt.y,
      },
    });
    this.canvasOpt.x = x;
    this.canvasOpt.y = y;
    this.updated = true;
    const xdiff = crect.x - x;
    const ydiff = crect.y - y;
    for(let l of this.linkedLayers.pos){
      const lrect = l.getCanvasRect();
      l.setCanvasPos(lrect.x - xdiff,lrect.y - ydiff,nextcallers);
    }
    for (let l of this.linkedLayers.move){
      const lrect = l.getCanvasRect();
      l.setCanvasPos(lrect.x - xdiff,lrect.y - ydiff,nextcallers);
      const lorect = l.getOutputRect();
      l.setOutputPos(lorect.x - xdiff,lorect.y - ydiff, nextcallers);
    }
  }
  setCanvasSize(w,h,callers){
    const crect = this.getCanvasRect();
    if (crect.w == w && crect.h == h){
      return;
    }
    let nextcallers = [];
    if (callers !== null && callers !== undefined){
      if (callers.indexOf(this.id) >= 0){
        return;
      }
      nextcallers = structuredClone(callers);
    }
    nextcallers.push(this.id);
    // copy
    if (w > 0 && h > 0){
      const canvas = this.main.window.document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      this.fill(canvas,[255,255,255,0]);
      if (this.canvasObj.width > 0 && this.canvasObj.height > 0){
        const thiscontext = this.canvasObj.getContext('2d');
        const thisimg = thiscontext.getImageData(0,0,this.canvasObj.width,this.canvasObj.width);
        const context = canvas.getContext('2d');
        context.putImageData(thisimg,0,0,0,0,this.canvasObj.width,this.canvasObj.height);
        this.pushHistory({
          type: Layer.DoMethodType.CanvasSizeChange,
          image: structuredClone(thisimg.data),
          size:{
            w: this.canvasObj.width,
            h: this.canvasObj.height,
          },
        });
        const nextimg = context.getImageData(0,0,w,h);
        this.canvasObj.width = w;
        this.canvasObj.height = h;
        thiscontext.putImageData(nextimg,0,0);
        this.canvasOpt.w = w;
        this.canvasOpt.h = h;
      }else{
        this.pushHistory({
          type: Layer.DoMethodType.CanvasSizeChange,
          image: null,
          size:{
            w: this.canvasObj.width,
            h: this.canvasObj.height,
          },
        });  
        this.canvasObj.width = w;
        this.canvasObj.height = h;
        this.canvasOpt.w = w;
        this.canvasOpt.h = h;
      }
    } else {
      const thiscontext = this.canvasObj.getContext('2d');
      const thisimg = thiscontext.getImageData(0,0,this.canvasObj.width,this.canvasObj.width);
      this.pushHistory({
        type: Layer.DoMethodType.CanvasSizeChange,
        image: structuredClone(thisimg.data),
        size:{
          w: this.canvasObj.width,
          h: this.canvasObj.height,
        },
      });
      w = h = 0;
      this.canvasObj.width = w;
      this.canvasObj.height = h;
      this.canvasOpt.w = w;
      this.canvasOpt.h = h;
    }
    this.updated = true;
    for(let l of this.linkedLayers.canvasSize){
      l.setCanvasSize(w,h,nextcallers);
    }
  }
  getCanvasRect(){
    return {
      x: this.canvasOpt.x,
      y: this.canvasOpt.y,
      w: this.canvasOpt.w,
      h: this.canvasOpt.h,
    };
  }
  setCanvasAlpha(alpha){
    if (this.canvasOpt.alpha == alpha){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.CanvasAlphaChange,
      alpha: this.canvasOpt.alpha,
    });
    this.canvasOpt.alpha = alpha;
    this.updated = true;
  }
  getCanvasAlpha(){
    return this.canvasOpt.alpha;
  }
  setCanvasOverlapMode(mode){
    if (this.canvasOpt.overlap == mode){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.CanvasOverlapChange,
      overlap: this.canvasOpt.overlap,
    });
    this.canvasOpt.overlap = mode;
    this.updated = true;
  }
  getCanvasOverlapMode(){
    return this.canvasOpt.overlap;
  }
  setOutputPos(x,y,callers){
    const crect = this.getOutputRect();
    if (crect.x == x && crect.y == y){
      return;
    }
    let nextcallers = [];
    if (callers !== null && callers !== undefined){
      if (callers.indexOf(this.id) >= 0){
        return;
      }
      nextcallers = structuredClone(callers);
    }
    nextcallers.push(this.id);
    this.pushHistory({
      type: Layer.DoMethodType.OutputPosChange,
      pos:{
        x: this.outputOpt.x,
        y: this.outputOpt.y,
      },
    });
    this.outputOpt.x = x;
    this.outputOpt.y = y;
    this.updated = true;
    const xdiff = crect.x - x;
    const ydiff = crect.y - y;
    for(let l of this.linkedLayers.window){
      const lrect = l.getOutputRect();
      l.setOutputPos(lrect.x - xdiff,lrect.y - ydiff,nextcallers);
    }
    for(let l of this.linkedLayers.move){
      const lrect = l.getCanvasRect();
      l.setCanvasPos(lrect.x - xdiff,lrect.y - ydiff,nextcallers);
      const lorect = l.getOutputRect();
      l.setOutputPos(lorect.x - xdiff,lorect.y - ydiff,nextcallers);
    }
  }
  setOutputSize(w,h,callers){
    const crect = this.getOutputRect();
    if (crect.w == w && crect.h == h){
      return;
    }
    let nextcallers = [];
    if (callers !== null && callers !== undefined){
      if (callers.indexOf(this.id) >= 0){
        return;
      }
      nextcallers = structuredClone(callers);
    }
    nextcallers.push(this.id);
    this.pushHistory({
      type: Layer.DoMethodType.OutputSizeChange,
      size:{ 
        w: this.outputOpt.w,
        h: this.outputOpt.h,
      }
    });
    this.outputOpt.w = w;
    this.outputOpt.h = h;
    this.updated = true;
    if (callers !== null && callers !== undefined){
      if (callers.indexOf(this) >= 0){
        return;
      }
    }
    for(let l of this.linkedLayers.size){
      const lrect = l.getOutputRect();
      l.setOutputPos(lrect.x - xdiff,lrecy.y - ydiff, nextcallers);
    }
  }
  getOutputRect(){
    return {
      x: this.outputOpt.x,
      y: this.outputOpt.y,
      w: this.outputOpt.w,
      h: this.outputOpt.h,
    };
  }
  setOutputAlpha(alpha){
    if (this.outputOpt.alpha == alpha){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.OutputAlphaChange,
      alpha: this.outputOpt.alpha,
    });
    this.outputOpt.alpha = alpha;
    this.updated = true;
  }
  getOutputAlpha(){
    return this.outputOpt.alpha;
  }
  setOutputOverlapMode(mode){
    if (this.outputOpt.overlap == mode){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.OutputOverlapChange,
      overlap: this.outputOpt.overlap,
    });
    this.outputOpt.overlap = mode;
    this.updated = true;
  }
  getOutputOverlapMode(){
    return this.outputOpt.overlap;
  }
  calcCacheRect(){
    let x = this.canvasOpt.x;
    let y = this.canvasOpt.y;
    let w = this.canvasOpt.w - this.canvasOpt.x;
    let h = this.canvasOpt.h - this.canvasOpt.y;
    if (this.outputOpt.x < x){
      x = this.outputOpt.x;
    }
    if (this.outputOpt.y < y){
      y = this.outputOpt.y;
    }
    if (this.outputOpt.w - this.outputOpt.x > w){
      w = this.outputOpt.w - this.outputOpt.x;
    }
    if (this.outputOpt.h - this.outputOpt.y > h){
      h = this.outputOpt.h - this.outputOpt.y;
    }
    for(let c of this.childLayers){
      const r = c.calcCacheRect();
      if (r.x < x){
        x = r.x;
      }
      if (r.y < y){
        y = r.y;
      }
      if (r.w - r.x > w){
        w = r.w - r.x;
      }
      if (r.h - r.y > h){
        h = r.h - r.y;
      }
    }
    if (w < 0){
      w = 1;
    }
    if (h < 0){
      h = 1;
    }
    return {
      x: x,
      y: y,
      w: w,
      h: h,
    };
  }
  doWriteCanvas2Canvas(srcCanvasObj,destCanvasObj,srcCanvasOpt,destCanvasRect){
    if (srcCanvasObj.width <= 0 || srcCanvasObj.height <= 0){
      return;
    }
    if (destCanvasObj.width <= 0 || destCanvasObj.height <= 0){
      return;
    }
    if (srcCanvasOpt.w <= 0 || srcCanvasOpt.h <= 0){
      return;
    }
    if (destCanvasRect.w <= 0 || destCanvasRect.h <= 0){
      return;
    }
    const context = destCanvasObj.getContext('2d');
    context.globalAlpha = srcCanvasOpt.alpha;
    context.globalCompositeOperation = srcCanvasOpt.overlap;
    let srcX = srcCanvasOpt.x;
    let srcY = srcCanvasOpt.y;
    let srcW = srcCanvasObj.width;
    let srcH = srcCanvasObj.height;
    let destX = (destCanvasRect.x);
    let destY = (destCanvasRect.y);
    let destW = srcCanvasObj.width;
    let destH = srcCanvasObj.height;
    console.log(srcCanvasObj,destCanvasObj)
    console.log(srcCanvasOpt,destCanvasRect,srcX,srcY,srcW,srcH,destX,destY,destW,destH);
    //if (destX != 0){
      try{ throw new Error(''); }catch(e){ console.log(e.stack); }
    //}
    context.drawImage(srcCanvasObj,srcX,srcY,srcW,srcH,destX,destY,destW,destH);
  }
  parentCacheClear(){
    for(let p of this.parentLayers){
      if (p instanceof Layer){
        p.fill(p.canvasCacheObj,p.defaultExternalColor);
        p.canvasCacheUpdated = true;
        p.parentCacheClear();
      }else if (p instanceof HTMLCanvasElement){
        this.fill(p,this.defaultExternalColor);
      }
    }
  }

  initCanvasCache(force){
    let updated = false;
    let canvasCacheRect = this.calcCacheRect();
    if (canvasCacheRect.x != this.canvasCacheRect.x ||
        canvasCacheRect.y != this.canvasCacheRect.y ||
        canvasCacheRect.w != this.canvasCacheRect.w ||
        canvasCacheRect.h != this.canvasCacheRect.h){
      this.canvasCacheRect = canvasCacheRect;
      this.canvasCacheObj.width = canvasCacheRect.w;
      this.canvasCacheObj.height = canvasCacheRect.h;
      updated = true;
      this.canvasCacheUpdated = true;
    }
    if (force == true || this.updated == true || this.canvasUpdated == true){
      this.canvasCacheUpdated = true;
    }
    if (this.updated == true || this.canvasUpdated == true){
      updated = true;
    }
    for(let c of this.childLayers){
      if (c instanceof Layer){
        if(c.initCanvasCache(force) == true){
          updated = true;
        }
      }else if (c instanceof HTMLCanvasElement){
        updated = true;
      }
    }
    if (force == true || updated == true){
      this.fill(this.canvasCacheObj,this.defaultExternalColor);
      this.canvasCacheUpdated = true;
      updated = true;
    }
    return updated;
  }
  checkCanvasUpdated(){
    if (this.updated == true || this.canvasUpdated == true){
      return true;
    }
    for(let c of this.childLayers){
      if (c instanceof Layer){
        if (c.checkCanvasUpdated() == true){
          return true;
        }else if (c instanceof HTMLCanvasElement){
          return true;
        }
      }
    }
    return false;
  }
  checkCanvasCacheUpdated(){
    if (this.canvasCacheUpdated == true){
      return true;
    }
    for(let c of this.childLayers){
      if (c instanceof Layer){
        if (c.checkCanvasCacheUpdated() == true){
          return true;
        }else if (c instanceof HTMLCanvasElement){
          return true;
        }
      }
    }
    return false;
  }
  doWriteChildLayers2Cache(force){
    let updated = false;
    if (this.updated == true || this.canvasUpdated == true){
      this.updated = false;
      this.canvasUpdated = false;
      updated = true;
    }
    const copyopt = structuredClone(this.canvasCacheRect);
    copyopt.x = 0;
    copyopt.y = 0;
    for(let c of this.childLayers){
      if (c instanceof Layer){
        let cupdated = false;
        if (force == true || c.checkCanvasUpdated() == true || this.checkCanvasCacheUpdated() == true){
          cupdated = c.doWriteCanvas2Cache(force);
          c.updated = false;
          c.canvasUpdated = false;
          c.canvasCacheUpdated = true;
        }
        if (cupdated == true || c.canvasCacheUpdated == true){
          this.doWriteCanvas2Canvas(c.canvasCacheObj,this.canvasCacheObj,c.outputOpt,copyopt);
          c.canvasCacheUpdated = false;
          updated = true;
        }
      }else if (c instanceof HTMLCanvasElement){
        this.doWriteCanvas2Canvas(c,this.canvasCache,{x:0,y:0,w:c.width,h:c.height,alpha:1,overlap:Layer.OverlapType.SourceOut},copyopt);
        updated = true;
      }
    }
    if (updated == true){
      this.canvasCacheUpdated = true;
    }
    return updated;
  }
  doWriteCanvas2Cache(force){
    let updated = this.doWriteChildLayers2Cache(force);
    if (force || updated == true || this.updated == true || this.canvasUpdated == true || this.canvasCacheUpdated == true){
      const copyopt = structuredClone(this.canvasOpt);
      copyopt.x = 0;
      copyopt.y = 0;
      this.doWriteCanvas2Canvas(this.canvasObj,this.canvasCacheObj,copyopt,this.canvasOpt);
      this.updated = false;
      this.canvasUpdated = false;
      this.canvasCacheUpdated = true;
      updated = true;
    }
    return updated;
  }
  getTopParentLayers(){
    let layers = [];
    if (this.parentLayers.length == 0){
      return [this.canvasObj];
    }
    for(let p of this.parentLayers){
      if (p instanceof Layer){
        layers = layers.concat(p.getTopParentLayers());
      }else if (p instanceof HTMLCanvasElement){
        layers.push(this);
      }
    }
    return layers;
  }
  doWriteCanvasCache2CanvasElement(force){
    let updated = false;
    for(let p of this.parentLayers){
      if (p instanceof Layer){
        // do nothing
      }else if (p instanceof HTMLCanvasElement){
        this.doWriteCanvas2Canvas(this.canvasCacheObj,p,{x:0,y:0,w:this.canvasCacheObj.width,h:this.canvasCacheObj.height,alpha:1,overlap:Layer.OverlapType.SourceOver},{x:0,y:0,w:p.width,h:p.height});
        updated = true;
      }
    }
    return updated;
  }
  doWrite(force){
    let updated = false;
    const initUpdate = this.initCanvasCache(force);
    if (initUpdate == true || this.canvasCacheUpdated == true){
      this.parentCacheClear();
    }
    for(let tlayer of this.getTopParentLayers()){
      if (tlayer instanceof Layer){
        if (tlayer.doWriteCanvas2Cache(force) == true){
          tlayer.doWriteCanvasCache2CanvasElement(force);
          updated = true;
        }
      }else if (tlayer instanceof HTMLCanvasElement){
        // do nothing
      }
    }
    return updated;
  }

  saveBackup(){
    this.canvasBackupObj.width = this.canvasObj.width;
    this.canvasBackupObj.height = this.canvasObj.height;
    const context = this.canvasObj.getContext('2d');
    const contextBackup = this.canvasBackupObj.getContext('2d');
    const img = context.getImageData(0,0,this.canvasObj.width,this.canvasObj.height);
    contextBackup.putImageData(img,0,0);
  }
  restoreBackup(){
    this.canvasObj.width = this.canvasBackupObj.width;
    this.canvasObj.height = this.canvasBackupObj.height;
    const context = this.canvasObj.getContext('2d');
    const contextBackup = this.canvasBackupObj.getContext('2d');
    const img = contextBackup.getImageData(0,0,this.canvasObj.width,this.canvasObj.height);
    context.putImageData(img,0,0);
    this.canvasUpdated = true;
  }
  doMethod(method, opt){
    if (method === null || method === undefined) return null;
    const context = this.canvasObj.getContext('2d');
    this.pushHistory({
      type: Layer.DoMethodType.Execute,
      method,
      opt: structuredClone(opt),
      image: structuredClone(context.getImageData(0,0,this.canvasObj.width,this.canvasObj.height).data),
      imageOpt: structuredClone(this.canvasOpt),
    });
    const r = method(this.canvasObj,opt);
    this.canvasUpdated = true;
    //this.doWrite();
  }
  setHistoryMax(v){
    this.historyMax = v;
    if (this.historyMax >= 0){
      while (this.history.length > this.historyMax){
        this.historyUnshift();
      }
    }
  }
  historyClear(){
    this.history = [];
    this.historyPos = -1;
  }
  historyDepth(){
    return this.history.length;
  }
  historyCurrent(){
    return this.historyPos;
  }
  historyUnshift(){
    if (this.history.length <= 1){
      this.history = [];
      this.historyPos = -1;
      return;
    }
    if (this.historyPos <= 0){
      return;
    }
    this.history.unshift();
    this.historyPos -= 1;
  }
  historyPop(){
    if (this.history.length <= 1){
      this.history = [];
      this.historyPos = -1;
      return;
    }
    if (this.historyPos >= this.history.length - 1){
      return;
    }
    this.history.pop();
  }
  doHistory(h){
    // TODO
    this.doWrite();
  }
  historyBack(){
    if (this.history.length < 1){
      return;
    }
    if (this.historyPos == -1){
      this.historyPos = this.history.length - 1;
      this.doHistory(this.history[this.historyPos]);
    }else{
      if (this.historyPos <= 0){
        return;
      }
      this.doHistory(this.history[this.historyPos]);
      this.historyPos -= 1;
    }
  }
  historyForward(){
    if (this.history.length < 1){
      return;
    }
    if (this.historyPos > this.history.length - 1){
      this.historyPos = this.history.length - 1;
    }
    if (this.historyPos == -1){
      return;
    }
    this.historyPos += 1;
    if (this.historyPos > this.history.length - 1){
      this.historyPos = -1;
    }
    if (this.historyPos == -1){
      return;
    }
    this.doHistory(this.history[this.historyPos]);
  }
}

// ================================================
// module: browser , from: Storage.js
// ================================================
// storage class
const Storage = self.Storage = class Storage {
  constructor(main,g_window) {
    this.main = main;
    this.g_window = g_window;
  }
  #realKeyPrefixName(){
    return APP_ID + "_" + this.main.tieName + "_";
  }
  #realKeyName(key) {
    return this.#realKeyPrefixName() + key;
  }
  save(key, value) {
    this.g_window.localStorage.setItem(this.#realKeyName(key),JSON.stringify(value));
  }
  load(key, defaultValue) {
    if (defaultValue === undefined) defaultValue = null;
    const v = this.g_window.localStorage.getItem(this.#realKeyName(key));
    if (v === null) return defaultValue;
    try{
      return JSON.parse(v);
    }catch(e){
      console.log(e);
      return defaultValue;
    }
  }
  delete(key) {
    this.g_window.localStorage.removeItem(this.#realKeyName(key));  
  }
  keys(prefix) {
    const r = [];
    const gprefx = this.#realKeyPrefixName();
    if (prefix === undefined || prefix === null) prefix = '';
    for (let i = 0; i < this.g_window.localStorage.length; i++) {
      const name = this.g_window.localStorage.key(i);
      if (name !== '') {
        if (name.startsWith(gprefx)) {
          const n = name.substring(gprefx.length);
          if (n.startsWith(prefix)){
            r.push(n.substring(prefix.length));
          }
        }
      } 
    }
    return r;
  }
  clear(prefix) {
    if (prefix === undefined || prefix == null) prefix = '';
    for(let k of this.keys(prefix)) {
      this.delete(k);
    }
  }
  clearAllStorageData(){
    this.g_window.localStorage.clear();
  }
}

app.modules.browser.vendor = {};

const vendor = self.vendor = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser.vendor";
app.modules.browser.vendor.blurhash = {};

const blurhash = self.blurhash = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser.vendor.blurhash";
// ================================================
// module: browser.vendor.blurhash , from: base83.js
// ================================================
const digitCharacters = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "#",
  "$",
  "%",
  "*",
  "+",
  ",",
  "-",
  ".",
  ":",
  ";",
  "=",
  "?",
  "@",
  "[",
  "]",
  "^",
  "_",
  "{",
  "|",
  "}",
  "~",
];

const decode83 = (str) => {
  let value = 0;
  for (let i = 0; i < str.length; i++) {
    const c = str[i];
    const digit = digitCharacters.indexOf(c);
    value = value * 83 + digit;
  }
  return value;
};

const encode83 = (n, length) => {
  var result = "";
  for (let i = 1; i <= length; i++) {
    let digit = (Math.floor(n) / Math.pow(83, length - i)) % 83;
    result += digitCharacters[Math.floor(digit)];
  }
  return result;
};

// ================================================
// module: browser.vendor.blurhash , from: decode.js
// ================================================
/**
 * Returns an error message if invalid or undefined if valid
 * @param blurhash
 */
const validateBlurhash = (blurhash) => {
  if (!blurhash || blurhash.length < 6) {
    throw new ValidationError(
      "The blurhash string must be at least 6 characters"
    );
  }

  const sizeFlag = decode83(blurhash[0]);
  const numY = Math.floor(sizeFlag / 9) + 1;
  const numX = (sizeFlag % 9) + 1;

  if (blurhash.length !== 4 + 2 * numX * numY) {
    throw new ValidationError(
      `blurhash length mismatch: length is ${
        blurhash.length
      } but it should be ${4 + 2 * numX * numY}`
    );
  }
};

const isBlurhashValid = (
  blurhash
) => {
  try {
    validateBlurhash(blurhash);
  } catch (error) {
    return { result: false, errorReason: error.message };
  }

  return { result: true };
};

const decodeDC = (value) => {
  const intR = value >> 16;
  const intG = (value >> 8) & 255;
  const intB = value & 255;
  return [sRGBToLinear(intR), sRGBToLinear(intG), sRGBToLinear(intB)];
};

const decodeAC = (value, maximumValue) => {
  const quantR = Math.floor(value / (19 * 19));
  const quantG = Math.floor(value / 19) % 19;
  const quantB = value % 19;

  const rgb = [
    signPow((quantR - 9) / 9, 2.0) * maximumValue,
    signPow((quantG - 9) / 9, 2.0) * maximumValue,
    signPow((quantB - 9) / 9, 2.0) * maximumValue,
  ];

  return rgb;
};

const decode = self.decode = (
  blurhash,
  width,
  height,
  punch
) => {
  validateBlurhash(blurhash);

  punch = punch | 1;

  const sizeFlag = decode83(blurhash[0]);
  const numY = Math.floor(sizeFlag / 9) + 1;
  const numX = (sizeFlag % 9) + 1;

  const quantisedMaximumValue = decode83(blurhash[1]);
  const maximumValue = (quantisedMaximumValue + 1) / 166;

  const colors = new Array(numX * numY);

  for (let i = 0; i < colors.length; i++) {
    if (i === 0) {
      const value = decode83(blurhash.substring(2, 6));
      colors[i] = decodeDC(value);
    } else {
      const value = decode83(blurhash.substring(4 + i * 2, 6 + i * 2));
      colors[i] = decodeAC(value, maximumValue * punch);
    }
  }

  const bytesPerRow = width * 4;
  const pixels = new Uint8ClampedArray(bytesPerRow * height);

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let r = 0;
      let g = 0;
      let b = 0;

      for (let j = 0; j < numY; j++) {
        const basisY = Math.cos((Math.PI * y * j) / height);
        for (let i = 0; i < numX; i++) {
          const basis = Math.cos((Math.PI * x * i) / width) * basisY;
          const color = colors[i + j * numX];
          r += color[0] * basis;
          g += color[1] * basis;
          b += color[2] * basis;
        }
      }

      let intR = linearTosRGB(r);
      let intG = linearTosRGB(g);
      let intB = linearTosRGB(b);

      pixels[4 * x + 0 + y * bytesPerRow] = intR;
      pixels[4 * x + 1 + y * bytesPerRow] = intG;
      pixels[4 * x + 2 + y * bytesPerRow] = intB;
      pixels[4 * x + 3 + y * bytesPerRow] = 255; // alpha
    }
  }
  return pixels;
};

// ================================================
// module: browser.vendor.blurhash , from: encode.js
// ================================================
const bytesPerPixel = 4;

const multiplyBasisFunction = (
  pixels,
  width,
  height,
  basisFunction
) => {
  let r = 0;
  let g = 0;
  let b = 0;
  const bytesPerRow = width * bytesPerPixel;

  for (let x = 0; x < width; x++) {
    const bytesPerPixelX = bytesPerPixel * x;

    for (let y = 0; y < height; y++) {
      const basePixelIndex = bytesPerPixelX + y * bytesPerRow;
      const basis = basisFunction(x, y);
      r +=
        basis * sRGBToLinear(pixels[basePixelIndex]);
      g +=
        basis * sRGBToLinear(pixels[basePixelIndex + 1]);
      b +=
        basis * sRGBToLinear(pixels[basePixelIndex + 2]);
    }
  }

  let scale = 1 / (width * height);

  return [r * scale, g * scale, b * scale];
};

const encodeDC = (value) => {
  const roundedR = linearTosRGB(value[0]);
  const roundedG = linearTosRGB(value[1]);
  const roundedB = linearTosRGB(value[2]);
  return (roundedR << 16) + (roundedG << 8) + roundedB;
};

const encodeAC = (value, maximumValue) => {
  let quantR = Math.floor(
    Math.max(
      0,
      Math.min(18, Math.floor(signPow(value[0] / maximumValue, 0.5) * 9 + 9.5))
    )
  );
  let quantG = Math.floor(
    Math.max(
      0,
      Math.min(18, Math.floor(signPow(value[1] / maximumValue, 0.5) * 9 + 9.5))
    )
  );
  let quantB = Math.floor(
    Math.max(
      0,
      Math.min(18, Math.floor(signPow(value[2] / maximumValue, 0.5) * 9 + 9.5))
    )
  );

  return quantR * 19 * 19 + quantG * 19 + quantB;
};

const encode = self.encode = (
  pixels,
  width,
  height,
  componentX,
  componentY
) => {
  if (componentX < 1 || componentX > 9 || componentY < 1 || componentY > 9) {
    throw new ValidationError("BlurHash must have between 1 and 9 components");
  }
  if (width * height * 4 !== pixels.length) {
    throw new ValidationError("Width and height must match the pixels array");
  }

  let factors = [];
  for (let y = 0; y < componentY; y++) {
    for (let x = 0; x < componentX; x++) {
      const normalisation = x == 0 && y == 0 ? 1 : 2;
      const factor = multiplyBasisFunction(
        pixels,
        width,
        height,
        (i, j) =>
          normalisation *
          Math.cos((Math.PI * x * i) / width) *
          Math.cos((Math.PI * y * j) / height)
      );
      factors.push(factor);
    }
  }

  const dc = factors[0];
  const ac = factors.slice(1);

  let hash = "";

  let sizeFlag = componentX - 1 + (componentY - 1) * 9;
  hash += encode83(sizeFlag, 1);

  let maximumValue;
  if (ac.length > 0) {
    let actualMaximumValue = Math.max(...ac.map((val) => Math.max(...val)));
    let quantisedMaximumValue = Math.floor(
      Math.max(0, Math.min(82, Math.floor(actualMaximumValue * 166 - 0.5)))
    );
    maximumValue = (quantisedMaximumValue + 1) / 166;
    hash += encode83(quantisedMaximumValue, 1);
  } else {
    maximumValue = 1;
    hash += encode83(0, 1);
  }

  hash += encode83(encodeDC(dc), 4);

  ac.forEach((factor) => {
    hash += encode83(encodeAC(factor, maximumValue), 2);
  });

  return hash;
};

// ================================================
// module: browser.vendor.blurhash , from: error.js
// ================================================
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
    this.message = message;
  }
}

// ================================================
// module: browser.vendor.blurhash , from: util.js
// ================================================
const sRGBToLinear = (value) => {
  let v = value / 255;
  if (v <= 0.04045) {
    return v / 12.92;
  } else {
    return Math.pow((v + 0.055) / 1.055, 2.4);
  }
};

const linearTosRGB = (value) => {
  let v = Math.max(0, Math.min(1, value));
  if (v <= 0.0031308) {
    return Math.trunc(v * 12.92 * 255 + 0.5);
  } else {
    return Math.trunc((1.055 * Math.pow(v, 1 / 2.4) - 0.055) * 255 + 0.5);
  }
};

const sign = (n) => (n < 0 ? -1 : 1);

const signPow = (val, exp) =>
  sign(val) * Math.pow(Math.abs(val), exp);


Object.assign(app.modules.browser.vendor.blurhash,self);

return self;
}).call({},self);
app.modules.browser.vendor.ThumbHash = {};

const ThumbHash = self.ThumbHash = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser.vendor.ThumbHash";
// ================================================
// module: browser.vendor.ThumbHash , from: thumbhash.js
// ================================================
/**
 * Encodes an RGBA image to a ThumbHash. RGB should not be premultiplied by A.
 *
 * @param w The width of the input image. Must be ≤100px.
 * @param h The height of the input image. Must be ≤100px.
 * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.
 * @returns The ThumbHash as a Uint8Array.
 */
const rgbaToThumbHash = self.rgbaToThumbHash = function rgbaToThumbHash(w, h, rgba) {
  // Encoding an image larger than 100x100 is slow with no benefit
  if (w > 100 || h > 100) throw new Error(`${w}x${h} doesn't fit in 100x100`)
  let { PI, round, max, cos, abs } = Math

  // Determine the average color
  let avg_r = 0, avg_g = 0, avg_b = 0, avg_a = 0
  for (let i = 0, j = 0; i < w * h; i++, j += 4) {
    let alpha = rgba[j + 3] / 255
    avg_r += alpha / 255 * rgba[j]
    avg_g += alpha / 255 * rgba[j + 1]
    avg_b += alpha / 255 * rgba[j + 2]
    avg_a += alpha
  }
  if (avg_a) {
    avg_r /= avg_a
    avg_g /= avg_a
    avg_b /= avg_a
  }

  let hasAlpha = avg_a < w * h
  let l_limit = hasAlpha ? 5 : 7 // Use fewer luminance bits if there's alpha
  let lx = max(1, round(l_limit * w / max(w, h)))
  let ly = max(1, round(l_limit * h / max(w, h)))
  let l = [] // luminance
  let p = [] // yellow - blue
  let q = [] // red - green
  let a = [] // alpha

  // Convert the image from RGBA to LPQA (composite atop the average color)
  for (let i = 0, j = 0; i < w * h; i++, j += 4) {
    let alpha = rgba[j + 3] / 255
    let r = avg_r * (1 - alpha) + alpha / 255 * rgba[j]
    let g = avg_g * (1 - alpha) + alpha / 255 * rgba[j + 1]
    let b = avg_b * (1 - alpha) + alpha / 255 * rgba[j + 2]
    l[i] = (r + g + b) / 3
    p[i] = (r + g) / 2 - b
    q[i] = r - g
    a[i] = alpha
  }

  // Encode using the DCT into DC (constant) and normalized AC (varying) terms
  let encodeChannel = (channel, nx, ny) => {
    let dc = 0, ac = [], scale = 0, fx = []
    for (let cy = 0; cy < ny; cy++) {
      for (let cx = 0; cx * ny < nx * (ny - cy); cx++) {
        let f = 0
        for (let x = 0; x < w; x++)
          fx[x] = cos(PI / w * cx * (x + 0.5))
        for (let y = 0; y < h; y++)
          for (let x = 0, fy = cos(PI / h * cy * (y + 0.5)); x < w; x++)
            f += channel[x + y * w] * fx[x] * fy
        f /= w * h
        if (cx || cy) {
          ac.push(f)
          scale = max(scale, abs(f))
        } else {
          dc = f
        }
      }
    }
    if (scale)
      for (let i = 0; i < ac.length; i++)
        ac[i] = 0.5 + 0.5 / scale * ac[i]
    return [dc, ac, scale]
  }
  let [l_dc, l_ac, l_scale] = encodeChannel(l, max(3, lx), max(3, ly))
  let [p_dc, p_ac, p_scale] = encodeChannel(p, 3, 3)
  let [q_dc, q_ac, q_scale] = encodeChannel(q, 3, 3)
  let [a_dc, a_ac, a_scale] = hasAlpha ? encodeChannel(a, 5, 5) : []

  // Write the constants
  let isLandscape = w > h
  let header24 = round(63 * l_dc) | (round(31.5 + 31.5 * p_dc) << 6) | (round(31.5 + 31.5 * q_dc) << 12) | (round(31 * l_scale) << 18) | (hasAlpha << 23)
  let header16 = (isLandscape ? ly : lx) | (round(63 * p_scale) << 3) | (round(63 * q_scale) << 9) | (isLandscape << 15)
  let hash = [header24 & 255, (header24 >> 8) & 255, header24 >> 16, header16 & 255, header16 >> 8]
  let ac_start = hasAlpha ? 6 : 5
  let ac_index = 0
  if (hasAlpha) hash.push(round(15 * a_dc) | (round(15 * a_scale) << 4))

  // Write the varying factors
  for (let ac of hasAlpha ? [l_ac, p_ac, q_ac, a_ac] : [l_ac, p_ac, q_ac])
    for (let f of ac)
      hash[ac_start + (ac_index >> 1)] |= round(15 * f) << ((ac_index++ & 1) << 2)
  return new Uint8Array(hash)
}

/**
 * Decodes a ThumbHash to an RGBA image. RGB is not be premultiplied by A.
 *
 * @param hash The bytes of the ThumbHash.
 * @returns The width, height, and pixels of the rendered placeholder image.
 */
const thumbHashToRGBA = self.thumbHashToRGBA = function thumbHashToRGBA(hash) {
  let { PI, min, max, cos, round } = Math

  // Read the constants
  let header24 = hash[0] | (hash[1] << 8) | (hash[2] << 16)
  let header16 = hash[3] | (hash[4] << 8)
  let l_dc = (header24 & 63) / 63
  let p_dc = ((header24 >> 6) & 63) / 31.5 - 1
  let q_dc = ((header24 >> 12) & 63) / 31.5 - 1
  let l_scale = ((header24 >> 18) & 31) / 31
  let hasAlpha = header24 >> 23
  let p_scale = ((header16 >> 3) & 63) / 63
  let q_scale = ((header16 >> 9) & 63) / 63
  let isLandscape = header16 >> 15
  let lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7)
  let ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7)
  let a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1
  let a_scale = (hash[5] >> 4) / 15

  // Read the varying factors (boost saturation by 1.25x to compensate for quantization)
  let ac_start = hasAlpha ? 6 : 5
  let ac_index = 0
  let decodeChannel = (nx, ny, scale) => {
    let ac = []
    for (let cy = 0; cy < ny; cy++)
      for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++)
        ac.push((((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2)) & 15) / 7.5 - 1) * scale)
    return ac
  }
  let l_ac = decodeChannel(lx, ly, l_scale)
  let p_ac = decodeChannel(3, 3, p_scale * 1.25)
  let q_ac = decodeChannel(3, 3, q_scale * 1.25)
  let a_ac = hasAlpha && decodeChannel(5, 5, a_scale)

  // Decode using the DCT into RGB
  let ratio = thumbHashToApproximateAspectRatio(hash)
  let w = round(ratio > 1 ? 32 : 32 * ratio)
  let h = round(ratio > 1 ? 32 / ratio : 32)
  let rgba = new Uint8Array(w * h * 4), fx = [], fy = []
  for (let y = 0, i = 0; y < h; y++) {
    for (let x = 0; x < w; x++, i += 4) {
      let l = l_dc, p = p_dc, q = q_dc, a = a_dc

      // Precompute the coefficients
      for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++)
        fx[cx] = cos(PI / w * (x + 0.5) * cx)
      for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++)
        fy[cy] = cos(PI / h * (y + 0.5) * cy)

      // Decode L
      for (let cy = 0, j = 0; cy < ly; cy++)
        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j++)
          l += l_ac[j] * fx[cx] * fy2

      // Decode P and Q
      for (let cy = 0, j = 0; cy < 3; cy++) {
        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j++) {
          let f = fx[cx] * fy2
          p += p_ac[j] * f
          q += q_ac[j] * f
        }
      }

      // Decode A
      if (hasAlpha)
        for (let cy = 0, j = 0; cy < 5; cy++)
          for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j++)
            a += a_ac[j] * fx[cx] * fy2

      // Convert to RGB
      let b = l - 2 / 3 * p
      let r = (3 * l - b + q) / 2
      let g = r - q
      rgba[i] = max(0, 255 * min(1, r))
      rgba[i + 1] = max(0, 255 * min(1, g))
      rgba[i + 2] = max(0, 255 * min(1, b))
      rgba[i + 3] = max(0, 255 * min(1, a))
    }
  }
  return { w, h, rgba }
}

/**
 * Extracts the average color from a ThumbHash. RGB is not be premultiplied by A.
 *
 * @param hash The bytes of the ThumbHash.
 * @returns The RGBA values for the average color. Each value ranges from 0 to 1.
 */
function thumbHashToAverageRGBA(hash) {
  let { min, max } = Math
  let header = hash[0] | (hash[1] << 8) | (hash[2] << 16)
  let l = (header & 63) / 63
  let p = ((header >> 6) & 63) / 31.5 - 1
  let q = ((header >> 12) & 63) / 31.5 - 1
  let hasAlpha = header >> 23
  let a = hasAlpha ? (hash[5] & 15) / 15 : 1
  let b = l - 2 / 3 * p
  let r = (3 * l - b + q) / 2
  let g = r - q
  return {
    r: max(0, min(1, r)),
    g: max(0, min(1, g)),
    b: max(0, min(1, b)),
    a
  }
}

/**
 * Extracts the approximate aspect ratio of the original image.
 *
 * @param hash The bytes of the ThumbHash.
 * @returns The approximate aspect ratio (i.e. width / height).
 */
function thumbHashToApproximateAspectRatio(hash) {
  let header = hash[3]
  let hasAlpha = hash[2] & 0x80
  let isLandscape = hash[4] & 0x80
  let lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7
  let ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7
  return lx / ly
}

/**
 * Encodes an RGBA image to a PNG data URL. RGB should not be premultiplied by
 * A. This is optimized for speed and simplicity and does not optimize for size
 * at all. This doesn't do any compression (all values are stored uncompressed).
 *
 * @param w The width of the input image. Must be ≤100px.
 * @param h The height of the input image. Must be ≤100px.
 * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.
 * @returns A data URL containing a PNG for the input image.
 */
const rgbaToDataURL = self.rgbaToDataURL = function rgbaToDataURL(w, h, rgba) {
  let row = w * 4 + 1
  let idat = 6 + h * (5 + row)
  let bytes = [
    137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0,
    w >> 8, w & 255, 0, 0, h >> 8, h & 255, 8, 6, 0, 0, 0, 0, 0, 0, 0,
    idat >>> 24, (idat >> 16) & 255, (idat >> 8) & 255, idat & 255,
    73, 68, 65, 84, 120, 1
  ]
  let table = [
    0, 498536548, 997073096, 651767980, 1994146192, 1802195444, 1303535960,
    1342533948, -306674912, -267414716, -690576408, -882789492, -1687895376,
    -2032938284, -1609899400, -1111625188
  ]
  let a = 1, b = 0
  for (let y = 0, i = 0, end = row - 1; y < h; y++, end += row - 1) {
    bytes.push(y + 1 < h ? 0 : 1, row & 255, row >> 8, ~row & 255, (row >> 8) ^ 255, 0)
    for (b = (b + a) % 65521; i < end; i++) {
      let u = rgba[i] & 255
      bytes.push(u)
      a = (a + u) % 65521
      b = (b + a) % 65521
    }
  }
  bytes.push(
    b >> 8, b & 255, a >> 8, a & 255, 0, 0, 0, 0,
    0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130
  )
  for (let [start, end] of [[12, 29], [37, 41 + idat]]) {
    let c = ~0
    for (let i = start; i < end; i++) {
      c ^= bytes[i]
      c = (c >>> 4) ^ table[c & 15]
      c = (c >>> 4) ^ table[c & 15]
    }
    c = ~c
    bytes[end++] = c >>> 24
    bytes[end++] = (c >> 16) & 255
    bytes[end++] = (c >> 8) & 255
    bytes[end++] = c & 255
  }
  return 'data:image/png;base64,' + btoa(String.fromCharCode(...bytes))
}

/**
 * Decodes a ThumbHash to a PNG data URL. This is a convenience function that
 * just calls "thumbHashToRGBA" followed by "rgbaToDataURL".
 *
 * @param hash The bytes of the ThumbHash.
 * @returns A data URL containing a PNG for the rendered ThumbHash.
 */
const thumbHashToDataURL = self.thumbHashToDataURL = function thumbHashToDataURL(hash) {
  let image = thumbHashToRGBA(hash)
  return rgbaToDataURL(image.w, image.h, image.rgba)
}


Object.assign(app.modules.browser.vendor.ThumbHash,self);

return self;
}).call({},self);

Object.assign(app.modules.browser.vendor,self);

return self;
}).call({},self);

Object.assign(app.modules.browser,self);

return self;
}).call({},self);

app.modules.canvasMethod = {};

const module_canvasMethod = self.module_canvasMethod = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".canvasMethod";
// ================================================
// module: canvasMethod , from: copy.js
// ================================================
const copy = self.copy = function copy(canvas, opt) {
  const option = {
    
  };
}

// ================================================
// module: canvasMethod , from: fillClearPattern.js
// ================================================
const fillClearPattern = self.fillClearPattern = function fillClearPattern(canvas, opt) {
  const context = canvas.getContext('2d');
  // fill white
  context.fillStyle = 'rgba(255, 255, 255, 1)';
  context.fillRect(0, 0, canvas.width, canvas.height);
  const len = 32;
  for(let x=0;x<canvas.width;x+=len){
    for(let y=0;y<canvas.height;y+=len){
      // clear pattern
      context.fillStyle = 'rgba(224, 224, 224, 1)';
      context.beginPath();
      context.moveTo(x+len/2,y);
      context.lineTo(x+len,y+len/2);
      context.lineTo(x+len/2,y+len);
      context.lineTo(x,y+len/2);
      context.closePath();
      context.fill();
    }
  }
}


Object.assign(app.modules.canvasMethod,self);

return self;
}).call({},self);

// ================================================
// source: Main.js
// ================================================
// Main (export) class
const Main = self.Main = class Main {
  constructor(targetObj, tieName, bodyObj) {
    this.$tie = Main.$tie;
    this.window = app.g_window;
    this.targetObj = targetObj;
    if (tieName === undefined || tieName === null) {
      tieName = 'default';
    }
    this.tieName = tieName;
    if (bodyObj === undefined || bodyObj === null){
      bodyObj = app.g_window.document.getElementsByTagName("body")[0];
    }
    this.bodyObj = bodyObj;
    this.storage = new modules.browser.Storage(this,this.window);
    this.history = {
      maxdepth: -1,
    };
    this.baseCanvas = this.window.document.createElement("canvas");
    this.baseCanvas.width = this.targetObj.getBoundingClientRect().width;
    this.baseCanvas.height = this.targetObj.getBoundingClientRect().height;
    this.defaultLayer = {
      bgcolor: "rgba(255,255,255,1)",
      fgcolor: "rgba(0,0,0,1)",
      externalColor: "rgba(0,216,216,1)",
      width: this.baseCanvas.width,
      height: this.baseCanvas.height,
    };
    this.targetObj.appendChild(this.baseCanvas);

    this.viewerLayer = new modules.browser.Layer(this);
    this.viewerLayer.setHistoryMax(0);
    this.viewerLayer.setExternalColor(this.defaultLayer.externalColor);
    this.viewerLayer.setCanvasSize(0,0);
    this.viewerLayer.addParentLayer(this.baseCanvas);

    this.clearpatternLayer = new modules.browser.Layer(this);
    this.clearpatternLayer.setHistoryMax(0);
    this.clearpatternLayer.addParentLayer(this.viewerLayer);
    this.viewerLayer.addChildLayer(this.clearpatternLayer);
    //this.clearpatternLayer.addLinkedLayer(this.viewerLayer,modules.browser.Layer.LinkedLayerType.CanvasSize);
    //this.viewerLayer.addLinkedLayer(this.clearpatternLayer,modules.browser.Layer.LinkedLayerType.CanvasSize);

    this.baseLayer = new modules.browser.Layer(this);
    this.baseLayer.setHistoryMax(0);
    this.baseLayer.addParentLayer(this.viewerLayer);
    this.viewerLayer.addChildLayer(this.baseLayer);
    this.baseLayer.addLinkedLayer(this.viewerLayer,modules.browser.Layer.LinkedLayerType.CanvasSize);
    this.viewerLayer.addLinkedLayer(this.baseLayer,modules.browser.Layer.LinkedLayerType.CanvasSize);
    this.baseLayer.addLinkedLayer(this.clearpatternLayer,modules.browser.Layer.LinkedLayerType.Move);
    this.clearpatternLayer.addLinkedLayer(this.baseLayer,modules.browser.Layer.LinkedLayerType.Move);

    this.layer = new modules.browser.Layer(this);
    this.baseLayer.addChildLayer(this.layer);
    this.layer.addParentLayer(this.baseLayer);
    this.baseLayer.addLinkedLayer(this.layer,modules.browser.Layer.LinkedLayerType.Move);
    this.layer.addLinkedLayer(this.baseLayer,modules.browser.Layer.LinkedLayerType.Move);

    this.layer2 = new modules.browser.Layer(this);
    this.baseLayer.addChildLayer(this.layer2);
    this.layer2.addParentLayer(this.baseLayer);
    this.baseLayer.addLinkedLayer(this.layer2,modules.browser.Layer.LinkedLayerType.Move);
    this.layer2.addLinkedLayer(this.baseLayer,modules.browser.Layer.LinkedLayerType.Move);

    this.clearpatternLayer.doMethod(modules.canvasMethod.fillClearPattern,null);
    this.viewerLayer.doWrite();
    this.window.addEventListener("DOMContentLoaded", () =>{
      const ovserver = new ResizeObserver(() => {
        this.baseCanvas.width = this.targetObj.getBoundingClientRect().width;
        this.baseCanvas.height = this.targetObj.getBoundingClientRect().height;
        this.viewerLayer.setCanvasSize(this.baseCanvas.width, this.baseCanvas.height);
        this.viewerLayer.setOutputPos(0,0);
        this.viewerLayer.setOutputSize(0,0);
        const cacheRect = this.viewerLayer.calcCacheRect();
        this.viewerLayer.setCanvasSize(0,0);
        this.viewerLayer.setOutputPos(cacheRect.x,cacheRect.y);
        this.viewerLayer.setOutputSize(cacheRect.w,cacheRect.h);
        //this.viewerLayer.setOutputSize(this.baseCanvas.width, this.baseCanvas.height);
        this.clearpatternLayer.doMethod(modules.canvasMethod.fillClearPattern,null);
        this.viewerLayer.doWrite();
      });
      ovserver.observe(this.targetObj);
    });
  }
  static $tie = $tie;
}

return Main;
}).call({},{});
