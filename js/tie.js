const Tie = (function(){
  const app = this.app = this;
  const modules = app.modules = {};
  const g_window = app.g_window = window;
  const APP_ID = app.APP_ID = "tie";
  const $tie = app.$tie = app;

  const self = this;
  const parent = self.parent = null;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID;
// ================================================
// source: functions.js
// ================================================
const regExpEscape = self.regExpEscape = function regExpEscape(str) {
  return str.replace(/[-\/\\^$*+?.()|\[\]{}]/g, '\\$&');
};

app.modules.utils = {};

const module_utils = self.module_utils = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".utils";
// ================================================
// module: utils , from: fonts.js
// ================================================
// fonts class
// fonts Sample
/*
console.log(Fonts.getFontNames());
*/
const Fonts = self.Fonts = class Fonts {
  static fontlist = [];
  static init = false;
  static fonthash = {};
  static getFontNames() {
    if (!Fonts.init){
      return null;
    }
    const r = [];
    for (let font of Fonts.fontlist){
      r.push(font.name);
    }
    return r;
  }
  static getFontLangs (name){
    if (!Fonts.init){
      return null;
    }
    return Fonts.fonthash[name].lang;
  }
  static {
    window.addEventListener('fontfamily_list-loaded',function(event){
      const fontfamily_list = event.detail;
      Fonts.fontlist = fontfamily_list;
      for (let font of fontfamily_list){
        Fonts.fonthash[font.name] = {
          lang: font.lang,
        };
      }
      Fonts.init = true;
    });
  };
};



// ================================================
// module: utils , from: MTRand.js
// ================================================
// rand class
// MTRand Sample
/*
console.log((new MTRand([0x123, 0x234, 0x345, 0x456])).randN(5));
console.log("1067595299  955945823  477289528 4107218783 4228976476");
*/
const MTRand = self.MTRand = class MTRand {
  constructor(seed){
    this.N = 624;
    this.M = 397;
    this.MATRIX_A = 0x9908b0df;
    this.UPPER_MASK = 0x80000000;
    this.LOWER_MASK = 0x7fffffff;
    this.mt = new Array(this.N);
    this.mti = this.N + 1;
    if (seed !== undefined){
      if (typeof seed === 'number'){
        this.init(seed);
      }else{
        this.init_by_array(seed);
      }
    }
  }
  xor(a,b){
    return ((((a >>> 16) & 0x0000ffff) ^ ((b >>> 16) & 0x0000ffff)) << 16) + ((a & 0x0000ffff) ^ (b & 0x0000ffff)) >>> 0;
  }
  mul(a,b){
    if (a < b){
      const t = a;
      a = b;
      b = t;
    }
    return ((((a >>> 16) & 0x0000ffff) * b) << 16) + ((a & 0x0000ffff) * b) >>> 0;
  }
  init(seed){
    this.seed = seed;
    this.mt[0] = seed >>> 0; // this.mt[0] = seed & 0xffffffff;
    for (this.mti=1; this.mti<this.N; this.mti++) {
      this.mt[this.mti] = (this.mul(1812433253 , (this.xor(this.mt[this.mti-1] , (this.mt[this.mti-1] >>> 30)))) + this.mti);
      this.mt[this.mti] = this.mt[this.mti] >>> 0; //this.mt[this.mti] &= 0xffffffff;
    }
  }
  init_by_array(seeds){
    this.seed = seeds;
    let i, j, k;
    this.init(19650218);
    i=1; j=0;
    k = (this.N>seeds.length ? this.N : seeds.length);
    for (; k; k--) {
      this.mt[i] = (this.xor(this.mt[i] , (this.mul(this.xor(this.mt[i-1] , (this.mt[i-1] >>> 30)) , 1664525)))) + seeds[j] + j;
      this.mt[i] = this.mt[i] >>> 0; // this.mt[i] &= 0xffffffff;
      i++; j++;
      if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
      if (j>=seeds.length) j=0;
    }
    for (k=this.N-1; k; k--) {
      this.mt[i] = (this.xor(this.mt[i] , (this.mul(this.xor(this.mt[i-1] , (this.mt[i-1] >>> 30)) , 1566083941)))) - i;
      this.mt[i] = this.mt[i] >>> 0; // this.mt[i] &= 0xffffffff;
      i++;
      if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
    }
    this.mt[0] = 0x80000000;        
  }
  rand(){
    let y;
    const mag01 = [0x0, this.MATRIX_A];
    if (this.mti >= this.N) {
      let kk;
      if (this.mti == this.N+1) this.init(5489);
      for (kk=0;kk<this.N-this.M;kk++) {
        y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
        this.mt[kk] = this.xor(this.xor(this.mt[kk+this.M] , (y >>> 1)) , mag01[y & 0x1]);
      }
      for (;kk<this.N-1;kk++) {
        y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
        this.mt[kk] = this.xor(this.xor(this.mt[kk+(this.M-this.N)] , (y >>> 1)) , mag01[y & 0x1]);
      }
      y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
      this.mt[this.N-1] = this.xor(this.xor(this.mt[this.M-1] , (y >>> 1)) , mag01[y & 0x1]);
      this.mti = 0;
    }
    y = this.mt[this.mti++];
    y = this.xor(y,(y >>> 11));
    y = this.xor(y,(y << 7) & 0x9d2c5680);
    y = this.xor(y,(y << 15) & 0xefc60000);
    y = this.xor(y,(y >>> 18));
    return y >>> 0;
  }
  randN(count){
    const r = new Array(count);
    for(let i=0;i<count;i++){
      r[i] = this.rand();
    }
    console.log(this)
    return r;
  }
}
const rand_vals = self.rand_vals = function rand_vals(seed,count){
  if (count === undefined || count === null || count <= 0) count = 1;
  console.log(this)
  return (new MTRand(seed)).randN(count);
}

app.modules.utils.vendor = {};

const vendor = self.vendor = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".utils.vendor";
app.modules.utils.vendor.fonts = {};

const fonts = self.fonts = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".utils.vendor.fonts";
// ================================================
// module: utils.vendor.fonts , from: fontfamily_list.js
// ================================================
/**
fontfamily-list

Copyright (c) 2021,2024 Ituki Kirihara/NI

This software is released under the MIT License.
http://opensource.org/licenses/mit-license.php

(Adobe-Blank)
This Font Software is licensed under the SIL Open Font License,
Version 1.1.

This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL

*/

(function(){
  const check_font = async function(){
    const check_font_list = [
      'arial',
      'arial black',
      'arial narrow',
      'arial unicode ms',
      'Century Gothic',
      'Franklin Gothic Medium',
      'Gulim',
      'Dotum',
      'Haettenschweiler',
      'Impact',
      'Ludica Sans Unicode',
      'Microsoft Sans Serif',
      'MS Sans Serif',
      'MV Boil',
      'New Gulim',
      'Tahoma',
      'Trebuchet',
      'Verdana',
      'Noto Sans SC',
      'PingFang SC',
      'Microsoft YaHei',
      'Noto Sans TC',
      'PingFang TC',
      'Microsoft JhengHei',
      'Noto Sans KR',
      'Nanum Gothic',
      'Malgun Gothic',
  
      'Batang',
      'Book Antiqua',
      'Bookman Old Style',
      'Century',
      'Estrangelo Edessa',
      'Garamond',
      'Georgia',
      'Gungsuh',
      'Latha',
      'Mangal',
      'MS Serif',
      'PMingLiU',
      'Palatino Linotype',
      'Raavi',
      'Roman',
      'Shruti',
      'Sylfaen',
      'Times New Roman',
      'Tunga',
      'Noto Serif SC',
      'Kaiti SC',
      'SimSun',
      'Noto Serif TC',
      'Kaiti TC',
      'PMingLiU',
      'Noto Serif KR',
      'Nanum Myeongjo',
      'Batang',
  
      'BatangChe',
      'Courier',
      'Courier New',
      'DotumChe',
      'GlimChe',
      'GungsuhChe',
      'HG行書体',
      'Lucida Console',
      'MingLiU',
      'ＭＳ ゴシック',
      'ＭＳ 明朝',
      'OCRB',
      'SimHei',
      'SimSun',
      'Small Fonts',
      'Terminal',
      
      'alba',
      'alba matter',
      'alba super',
      'baby kruffy',
      'Chick',
      'Croobie',
      'Fat',
      'Freshbot',
      'Frosty',
      'GlooGun',
      'Jokewood',
      'Modern',
      'Monotype Corsiva',
      'Poornut',
      'Pussycat Snickers',
      'Weltron Urban',
  
      'Comic Sans MS',
      'HGP行書体',
      'HG正楷書体-PRO',
      'Jenkins v2.0',
      'Script',
  
      'MS UI Gothic',
      'ＭＳ Ｐゴシック',
      'ＭＳ ゴシック',
      'ＭＳ Ｐ明朝',
      'ＭＳ 明朝',
      'メイリオ',
      'Meiryo UI',
      '游ゴシック',
      '游明朝',
      'ヒラギノ角ゴ Pro W3',
      'ヒラギノ角ゴ ProN W3',
      'ヒラギノ角ゴ Pro W6',
      'ヒラギノ角ゴ ProN W6',
      'ヒラギノ角ゴ Std W8',
      'ヒラギノ角ゴ StdN W8',
      'ヒラギノ丸ゴ Pro W4',
      'ヒラギノ丸ゴ ProN W4',
      'ヒラギノ明朝 Pro W3',
      'ヒラギノ明朝 ProN W3',
      'ヒラギノ明朝 Pro W6',
      'ヒラギノ明朝 ProN W6',
      '游ゴシック体',
      '游明朝体',
      'Osaka',
      'Osaka－等幅',
      'Droid Sans',
      'Roboto',
  
      'Noto Sans JP',
      'Noto Sans CJK JP',
      'Noto Sans CJK',
    ];

    const check_font_list_f = [
      'sans-serif',
      'serif',
      'system-ui',
      'monospace',
      'cursive',
      'fantasy',
    ];
    const check_code = "a";
    const check_codepoint = {
      ja: 'あ',
      zh: '开',
      ko: '아',
      ru: 'Б',
    };
    //while(check_font_list.length>0) check_font_list.pop()
    /*
    if ('query' in navigator.permissions){
      const status = await navigator.permissions.query({ name: "local-fonts" })
      if (status.state === "granted"){
        if('fonts' in navigator){
          const iterableFontObject = navigator.fonts.query();
          for await (const metadata of iterableFontObject) {
            const fontname = metadata.family;
            if (!check_font_list.includes(fontname)) check_font_list.push(fontname);
          }  
        }
      }     
    }
    */
    const f = "Blank";
  
    const style = document.createElement('style');
    document.head.appendChild(style);
    style.sheet.insertRule('@font-face{font-family:' + f + ';src:url("data:font/opentype;base64,T1RUTwAKAIAAAwAgQ0ZGIDTeCDQAACFkAAAZPERTSUcAAAABAABKqAAAAAhPUy8yAF+xmwAAARAAAABgY21hcCRDbtEAAAdcAAAZ6GhlYWQFl9tDAAAArAAAADZoaGVhB1oD7wAAAOQAAAAkaG10eAPoAHwAADqgAAAQBm1heHAIAVAAAAABCAAAAAZuYW1lIE0HkgAAAXAAAAXrcG9zdP+4ADIAACFEAAAAIAABAAAAAQuFfcPHtV8PPPUAAwPoAAAAANFMRfMAAAAA0UxF8wB8/4gDbANwAAAAAwACAAAAAAAAAAEAAANw/4gAAAPoAHwAfANsAAEAAAAAAAAAAAAAAAAAAAACAABQAAgBAAAAAwPoAZAABQAAAooCWAAAAEsCigJYAAABXgAyANwAAAAAAAAAAAAAAAD3/67/+9///w/gAD8AAAAAQURCTwBAAAD//wNw/4gAAANwAHhgLwH/AAAAAAAAAAAAAAAgAAAAAAARANIAAQAAAAAAAQALAAAAAQAAAAAAAgAHAAsAAQAAAAAAAwAbABIAAQAAAAAABAALAAAAAQAAAAAABQA6AC0AAQAAAAAABgAKAGcAAwABBAkAAACUAHEAAwABBAkAAQAWAQUAAwABBAkAAgAOARsAAwABBAkAAwA2ASkAAwABBAkABAAWAQUAAwABBAkABQB0AV8AAwABBAkABgAUAdMAAwABBAkACAA0AecAAwABBAkACwA0AhsAAwABBAkADQKWAk8AAwABBAkADgA0BOVBZG9iZSBCbGFua1JlZ3VsYXIxLjA0NTtBREJPO0Fkb2JlQmxhbms7QURPQkVWZXJzaW9uIDEuMDQ1O1BTIDEuMDQ1O2hvdGNvbnYgMS4wLjgyO21ha2VvdGYubGliMi41LjYzNDA2QWRvYmVCbGFuawBDAG8AcAB5AHIAaQBnAGgAdAAgAKkAIAAyADAAMQAzACwAIAAyADAAMQA1ACAAQQBkAG8AYgBlACAAUwB5AHMAdABlAG0AcwAgAEkAbgBjAG8AcgBwAG8AcgBhAHQAZQBkACAAKABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwApAC4AQQBkAG8AYgBlACAAQgBsAGEAbgBrAFIAZQBnAHUAbABhAHIAMQAuADAANAA1ADsAQQBEAEIATwA7AEEAZABvAGIAZQBCAGwAYQBuAGsAOwBBAEQATwBCAEUAVgBlAHIAcwBpAG8AbgAgADEALgAwADQANQA7AFAAUwAgADEALgAwADQANQA7AGgAbwB0AGMAbwBuAHYAIAAxAC4AMAAuADgAMgA7AG0AYQBrAGUAbwB0AGYALgBsAGkAYgAyAC4ANQAuADYAMwA0ADAANgBBAGQAbwBiAGUAQgBsAGEAbgBrAEEAZABvAGIAZQAgAFMAeQBzAHQAZQBtAHMAIABJAG4AYwBvAHIAcABvAHIAYQB0AGUAZABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwB0AHkAcABlAC8AVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAgAFQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAaQBzACAAZABpAHMAdAByAGkAYgB1AHQAZQBkACAAbwBuACAAYQBuACAAIgBBAFMAIABJAFMAIgAgAEIAQQBTAEkAUwAsACAAVwBJAFQASABPAFUAVAAgAFcAQQBSAFIAQQBOAFQASQBFAFMAIABPAFIAIABDAE8ATgBEAEkAVABJAE8ATgBTACAATwBGACAAQQBOAFkAIABLAEkATgBEACwAIABlAGkAdABoAGUAcgAgAGUAeABwAHIAZQBzAHMAIABvAHIAIABpAG0AcABsAGkAZQBkAC4AIABTAGUAZQAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUAIABmAG8AcgAgAHQAaABlACAAcwBwAGUAYwBpAGYAaQBjACAAbABhAG4AZwB1AGEAZwBlACwAIABwAGUAcgBtAGkAcwBzAGkAbwBuAHMAIABhAG4AZAAgAGwAaQBtAGkAdABhAHQAaQBvAG4AcwAgAGcAbwB2AGUAcgBuAGkAbgBnACAAeQBvAHUAcgAgAHUAcwBlACAAbwBmACAAdABoAGkA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wwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wEAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRAVIBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwIsAi0CLgIvAjACMQIyAjMCNAI1AjYCNwI4AjkCOgI7AjwCPQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoDGwMcAx0DHgMfAyADIQMiAyMDJAMlAyYDJwMoAykDKgMrAywDLQMuAy8DMAMxAzIDMwM0AzUDNgM3AzgDOQM6AzsDPAM9Az4DPwNAA0EDQgNDA0QDRQNGA0cDSANJA0oDSwNMA00DTgNPA1ADUQNSA1MDVANVA1YDVwNYA1kDWgNbA1wDXQNeA18DYANhA2IDYwNkA2UDZgNnA2gDaQNqA2sDbANtA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgN/A4ADgQOCA4MDhAOFA4YDhwOIA4kDigOLA4wDjQOOA48DkAORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwOgA6EDogOjA6QDpQOmA6cDqAOpA6oDqwOsA60DrgOvA7ADsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+A78DwAPBA8IDwwPEA8UDxgPHA8gDyQPKA8sDzAPNA84DzwPQA9ED0gPTA9QD1QPWA9cD2APZA9oD2wPcA90D3gPfA+AD4QPiA+MD5APlA+YD5wPoA+kD6gPrA+wD7QPuA+8D8APxA/ID8wP0A/UD9gP3A/gD+QP6A/sD/AP9A/4D/wQABAEEAgQDBAQEBQQGBAcECAQJBAoECwQMBA0EDgQPBBAEEQQSBBMEFAQVBBYEFwQYBBkEGgQbBBwEHQQeBB8EIAQhBCIEIwQkBCUEJgQnBCgEKQQqBCsELAQtBC4ELwQwBDEEMgQzBDQENQQ2BDcEOAQ5BDoEOwQ8BD0EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE8EUARRBFIEUwRUBFUEVgRXBFgEWQRaBFsEXARdBF4EXwRgBGEEYgRjBGQEZQRmBGcEaARpBGoEawRsBG0EbgRvBHAEcQRyBHMEdAR1BHYEdwR4BHkEegR7BHwEfQR+BH8EgASBBIIEgwSEBIUEhgSHBIgEiQSKBIsEjASNBI4EjwSQBJEEkgSTBJQElQSWBJcEmASZBJoEmwScBJ0EngSfBKAEoQSiBKMEpASlBKYEpwSoBKkEqgSrBKwErQSuBK8EsASxBLIEswS0BLUEtgS3BLgEuQS6BLsEvAS9BL4EvwTABMEEwgTDBMQExQTGBMcEyATJBMoEywTMBM0EzgTPBNAE0QTSBNME1ATVBNYE1wTYBNkE2gTbBNwE3QTeBN8E4AThBOIE4wTkBOUE5gTnBOgE6QTqBOsE7ATtBO4E7wTwBPEE8gTzBPQE9QT2BPcE+AT5BPoE+wT8BP0E/gT/BQAFAQUCBQMFBAUFBQYFBwUIBQkFCgULBQwFDQUOBQ8FEAURBRIFEwUUBRUFFgUXBRgFGQUaBRsFHAUdBR4FHwUgBSEFIgUjBSQFJQUmBScFKAUpBSoFKwUsBS0FLgUvBTAFMQUyBTMFNAU1BTYFNwU4BTkFOgU7BTwFPQU+BT8FQAVBBUIFQwVEBUUFRgVHBUgFSQVKBUsFTAVNBU4FTwVQBVEFUgVTBVQFVQVWBVcFWAVZBVoFWwVcBV0FXgVfBWAFYQViBWMFZAVlBWYFZwVoBWkFagVrBWwFbQVuBW8FcAVxBXIFcwV0BXUFdgV3BXgFeQV6BXsFfAV9BX4FfwWABYEFggWDBYQFhQWGBYcFiAWJBYoFiwWMBY0FjgWPBZAFkQWSBZMFlAWVBZYFlwWYBZkFmgWbBZwFnQWeBZ8FoAWhBaIFowWkBaUFpgWnBagFqQWqBasFrAWtBa4FrwWwBbEFsgWzBbQFtQW2BbcFuAW5BboFuwW8Bb0FvgW/BcAFwQXCBcMFxAXFBcYFxwXIBckFygXLBcwFzQXOBc8F0AXRBdIF0wXUBdUF1gXXBdgF2QXaBdsF3AXdBd4F3wXgBeEF4gXjBeQF5QXmBecF6AXpBeoF6wXsBe0F7gXvBfAF8QXyBfMF9AX1BfYF9wX4BfkF+gX7BfwF/QX+Bf8GAAYBBgIGAwYEBgUGBgYHBggGCQYKBgsGDAYNBg4GDwYQBhEGEgYTBhQGFQYWBhcGGAYZBhoGGwYcBh0GHgYfBiAGIQYiBiMGJAYlBiYGJwYoBikGKgYrBiwGLQYuBi8GMAYxBjIGMwY0BjUGNgY3BjgGOQY6BjsGPAY9Bj4GPwZABkEGQgZDBkQGRQZGBkcGSAZJBkoGSwZMBk0GTgZPBlAGUQZSBlMGVAZVBlYGVwZYBlkGWgZbBlwGXQZeBl8GYAZhBmIGYwZkBmUGZgZnBmgGaQZqBmsGbAZtBm4GbwZwBnEGcgZzBnQGdQZ2BncGeAZ5BnoGewZ8Bn0GfgZ/BoAGgQaCBoMGhAaFBoYGhwaIBokGigaLBowGjQaOBo8GkAaRBpIGkwaUBpUGlgaXBpgGmQaaBpsGnAadBp4GnwagBqEGogajBqQGpQamBqcGqAapBqoGqwasBq0GrgavBrAGsQayBrMGtAa1BrYGtwa4BrkGuga7BrwGvQa+Br8GwAbBBsIGwwbEBsUGxgbHBsgGyQbKBssGzAbNBs4GzwbQBtEG0gbTBtQG1QbWBtcG2AbZBtoG2wbcBt0G3gbfBuAG4QbiBuMG5AblBuYG5wboBukG6gbrBuwG7QbuBu8G8AbxBvIG8wb0BvUG9gb3BvgG+Qb6BvsG/Ab9Bv4G/wcABwEHAgcDBwQHBQcGBwcHCAcJBwoHCwcMBw0HDgcPBxAHEQcSBxMHFAcVBxYHFwcYBxkHGgcbBxwHHQceBx8HIAchByIHIwckByUHJgcnBygHKQcqBysHLActBy4HLwcwBzEHMgczBzQHNQc2BzcHOAc5BzoHOwc8Bz0HPgc/B0AHQQdCB0MHRAdFB0YHRwdIB0kHSgdLB0wHTQdOB08HUAdRB1IHUwdUB1UHVgdXB1gHWQdaB1sHXAddB14HXwdgB2EHYgdjB2QHZQdmB2cHaAdpB2oHawdsB20HbgdvB3AHcQdyB3MHdAd1B3YHdwd4B3kHegd7B3wHfQd+B38HgAeBB4IHgweEB4UHhgeHB4gHiQeKB4sHjAeNB44HjweQB5EHkgeTB5QHlQeWB5cHmAeZB5oHmwecB50HngefB6AHoQeiB6MHpAelB6YHpweoB6kHqgerB6wHrQeuB68HsAexB7IHswe0B7UHtge3B7gHuQe6B7sHvAe9B74HvwfAB8EHwgfDB8QHxQfGB8cHyAfJB8oHywfMB80HzgfPB9AH0QfSB9MH1AfVB9YH1wfYB9kH2gfbB9wH3QfeB98H4AfhB+IH4wfkB+UH5gfnB+gH6QfqB+sH7AftB+4H7wfwB/EH8gfzB/QH9Qf2B/cH+Af5B/oH+wf8B/0H/gf/CAAIAQgCCAMIBAgFCAYIBwgICAkICggLCAwIDQgOCA8IEAgRCBIIEwgUCBUIFggXCBgIGQgaCBsIHAgdCB4IHwggCCEIIggjCCQIJQgmCCcIKAgpCCoIKwgsCC0ILggvCDAIMQgyCDMINAg1CDYINwg4CDkIOgg7CDwIPQg+CD8IQAhBCEIIQwhECEUIRghHCEgISQhKCEsg+wy3+iS3AfcQt/kstwP3EPoEFf58+YT6fAf9WP4nFfnSB/fF/DMFprAV+8X4NwX49gamYhX90gf7xfgzBXBmFffF/DcF/PYGDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OAAEBAQr4HwwmmhwZLRL7joscBUaLBr0KvQv65xUD6AB8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA==");}', 0);
  
    const check_str = async function(fontname,str){
      let escaped_fontname = fontname
      if (!check_font_list_f.includes(fontname)){
        escaped_fontname = '"' + fontname.replace(/"/g, '"') + '"';
      }
      const chkobj = document.createElement('span');
      chkobj.innerHTML = str;
      chkobj.style.height = 0
      chkobj.style.overflow = 'hidden'
      chkobj.style.position = 'absolute'
      chkobj.style.visibility = 'hidden'
      chkobj.style.fontSize = '72px';
      chkobj.style.fontFamily = escaped_fontname + ',' + f;
      document.body.appendChild(chkobj);
      return await document.fonts.load("72px '" + fontname + "','" + f + "'")
      .then(function (fontset){
        var ok = chkobj.offsetWidth > 1;
        document.body.removeChild(chkobj);
        return ok;
      }).catch(function (err){
        document.body.removeChild(chkobj);
        return false;
      })
    };
    const check = async function(name) {
      if (await check_str(name,check_code)){
        const ret = { name, lang: {} };
        for (let lang of Object.keys(check_codepoint)) {
          ret.lang[lang] = false;
          if (await check_str(name,check_codepoint[lang])) {
            ret.lang[lang] = true;
          }
        }
        return ret;
      } else {
        return null;
      }
    };
    const ret = [];
    const target = check_font_list.concat(check_font_list_f);
    for (let fontname of target) {
      const d = await check(fontname);
      if (d) ret.push(d);
    }
    document.head.removeChild(style);
    var ev = new CustomEvent('fontfamily_list-loaded', {detail: ret});
    window.dispatchEvent(ev);
  }
  document.addEventListener('DOMContentLoaded',function(){
    check_font();
  });
})();



Object.assign(app.modules.utils.vendor.fonts,self);

return self;
}).call({},self);

Object.assign(app.modules.utils.vendor,self);

return self;
}).call({},self);

Object.assign(app.modules.utils,self);

return self;
}).call({},self);

app.modules.browser = {};

const module_browser = self.module_browser = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser";
app.modules.browser.canvasMethod = {};

const canvasMethod = self.canvasMethod = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser.canvasMethod";
// ================================================
// module: browser.canvasMethod , from: fillClearPattern.js
// ================================================
const fillClearPattern = self.fillClearPattern = function fillClearPattern(canvas, opt) {
  if (!opt) {
    opt = {};
  }
  if (!canvas) {
    return;
  }
  const rawCanvas = parent.Canvas.getRawCanvas(canvas);
  if (!rawCanvas) {
    return;
  }
  const context = rawCanvas.getContext('2d');
  // fill white
  context.fillStyle = 'rgba(255, 255, 255, 1)';
  context.fillRect(0, 0, rawCanvas.width, rawCanvas.height);
  const len = 16;
  for(let x=0;x<rawCanvas.width;x+=len){
    for(let y=0;y<rawCanvas.height;y+=len){
      // clear pattern
      context.fillStyle = 'rgba(224, 224, 224, 1)';
      context.beginPath();
      context.moveTo(x+len/2,y);
      context.lineTo(x+len,y+len/2);
      context.lineTo(x+len/2,y+len);
      context.lineTo(x,y+len/2);
      context.closePath();
      context.fill();
    }
  }
}


Object.assign(app.modules.browser.canvasMethod,self);

return self;
}).call({},self);
app.modules.browser.colorTheme = {};

const colorTheme = self.colorTheme = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser.colorTheme";
// ================================================
// module: browser.colorTheme , from: default.js
// ================================================
const Default = self.Default = {
  WindowIconBackgroundColor: "rgba(0,0,0,0)",
  WindowIconColor: "rgba(95,99,104,1)",
  WindowIconHoverBackgroundColor: "rgba(150,150,150,1)",
  WindowIconHoverColor: "rgba(95,99,104,1)",
  WindowTitlebarBackgroundColor: "rgba(220,220,220,1)",
  WindowTitlebarColor: "rgba(0,0,0,1)",
  WindowTitlebarTopBackgroundColor: "rgba(200,200,200,1)",
  WindowTitlebarTopColor: "rgba(0,0,0,0.8)",
  WindowBorderColor: "rgba(0,0,0,1)",
  WindowBackgroundColor: "rgba(255,255,255,1)",
  WindowTooltipBackgroundColor: "rgba(0,0,0,0.8)",
  WindowTooltipColor: "rgba(255,255,255,1)",
}


Object.assign(app.modules.browser.colorTheme,self);

return self;
}).call({},self);
// ================================================
// module: browser , from: canvas.js
// ================================================
const Canvas = self.Canvas = class Canvas {
  static OverlapType = {
    SourceOver:"source-over",
    SourceIn:"source-in",
    SourceOut:"source-out",
    SourceAtop:"source-atop",
    DestinationOver:"destination-over",
    DestinationIn:"destination-in",
    DestinationOut:"destination-out",
    DestinationAtop:"destination-atop",
    Lighter:"lighter",
    Copy:"copy",
    Xor:"xor",
    Multiply:"multiply",
    Screen:"screen",
    Overlay:"overlay",
    Darken:"darken",
    Lighten:"lighten",
    ColorDodge:"color-dodge",
    ColorBurn:"color-burn",
    HardLight:"hard-light",
    SoftLight:"soft-light",
    Difference:"difference",
    Exclusion:"exclusion",
    Hue:"hue",
    Saturation:"saturation",
    Color:"color",
    Luminosity:"luminosity",
  };
  static ResizeType = {
    Center:"center",
    TopLeft:"top-left",
    TopRight:"top-right",
    BottomLeft:"bottom-left",
    BottomRight:"bottom-right",
  };
  static ScalingType = {
    None:"none",
    Smoothing:"smoothing",
    Nearest:"nearest",
    Bilinear:"bilinear",
    Bicubic:"bicubic",
  };
  

  static currentCanvasId = 0;
  constructor(main, width, height) {
    this.main = main;
    Canvas.currentCanvasId += 1;
    this.id = Canvas.currentCanvasId;
    this.raw = this.main.window.document.createElement('canvas');
    this.raw.id = `tie_${this.main.tieName}_canvas_${this.id}`;
    this.raw.width = width;
    this.raw.height = height;
    this.drawOverlapType = Canvas.OverlapType.SourceOver;
    this.drawAlpha = 1;
    this.resizeType = Canvas.ResizeType.TopLeft;
    this.scalingType = Canvas.ScalingType.Smoothing;
  }
  static getRawCanvas(canvas){
    if (canvas instanceof Canvas){
      canvas = canvas.raw;
    }else if (canvas instanceof HTMLCanvasElement){
      canvas = canvas;
    }else{
      return null;
    }
    return canvas;
  }
  rcopyRect(destCanvas,w,h,sx,sy,dx,dy){
    destCanvas = Canvas.getRawCanvas(destCanvas);
    if (destCanvas === null){
      return false;
    }
    if (w === undefined){
      w = this.raw.width;
    }
    if (h === undefined){
      h = this.raw.height;
    }
    if (sx === undefined){
      sx = 0;
    }
    if (sy === undefined){
      sy = 0;
    }
    if (dx === undefined){
      dx = sx;
    }
    if (dy === undefined){
      dy = sy;
    }
    const srcContext = this.raw.getContext('2d');
    const destContext = destCanvas.getContext('2d');
    const srcimg = srcContext.getImageData(sx,sy,w,h);
    destContext.putImageData(srcimg,dx,dy,0,0,w,h);
  }
  rcopy(destCanvas){
    this.rcopyRect(destCanvas);
  }
  copyRect(srcCanvas,w,h,sx,sy,dx,dy){
    srcCanvas = Canvas.getRawCanvas(srcCanvas);
    if (srcCanvas === null){
      return false;
    }
    if (w === undefined){
      w = srcCanvas.width;
    }
    if (h === undefined){
      h = srcCanvas.height;
    }
    if (sx === undefined){
      sx = 0;
    }
    if (sy === undefined){
      sy = 0;
    }
    if (dx === undefined){
      dx = sx;
    }
    if (dy === undefined){
      dy = sy;
    }
    const srcContext = srcCanvas.getContext('2d');
    const destContext = this.raw.getContext('2d');
    const srcimg = srcContext.getImageData(sx,sy,w,h);
    destContext.putImageData(srcimg,dx,dy);
  }
  copy(srcCanvas){
    this.copyRect(srcCanvas);
  }
  fillRect(x,y,w,h,color){
    if (x === undefined){
      x = 0;
    }
    if (y === undefined){
      y = 0;
    }
    if (w === undefined){
      w = this.raw.width;
    }
    if (h === undefined){
      h = this.raw.height;
    }
    const colorAry = Color.colorToArray(color);
    const context = this.raw.getContext('2d');
    const contextimg = context.getImageData(x,y,w,h);
    for(let i = 0; i < contextimg.data.length; i += 4){
      contextimg.data[i] = colorAry[0];
      contextimg.data[i + 1] = colorAry[1];
      contextimg.data[i + 2] = colorAry[2];
      contextimg.data[i + 3] = colorAry[3];
    }
    context.putImageData(contextimg,x,y);
  }
  fill(color){
    this.fillRect(0,0,this.raw.width,this.raw.height,color);
  }
  drawRect(canvas,sx,sy,sw,sh,dx,dy,dw,dh){
    canvas = Canvas.getRawCanvas(canvas);
    if (canvas === null){
      return false;
    }
    if (sx === undefined){
      sx = 0;
    }
    if (sy === undefined){
      sy = 0;
    }
    if (sw === undefined){
      sw = this.raw.width;
    }
    if (sh === undefined){
      sh = this.raw.height;
    }
    if (dx === undefined){
      dx = sx;
    }
    if (dy === undefined){
      dy = sy;
    }
    if (dw === undefined){
      dw = sw;
    }
    if (dh === undefined){
      dh = sh;
    }
    const scontext = this.raw.getContext('2d');
    scontext.save();
    scontext.globalAlpha = this.drawAlpha;
    scontext.globalCompositeOperation = this.drawOverlapType;
    scontext.drawImage(canvas,sx,sy,sw,sh,dx,dy,dw,dh);
    scontext.restore();
    return true;
  }
  draw(canvas,dx,dy){
    return this.drawRect(canvas,0,0,this.raw.width,this.raw.height,dx,dy,this.raw.width,this.raw.height);
  }
  getRect(){
    return {
      x: 0,
      y: 0,
      w: this.raw.width,
      h: this.raw.height,
    };
  }
  setResizeType(type){
    this.resizeType = type;
  }
  getHTMLCanvas(){
    return this.raw;
  }
  getHTMLCanvasContext(){
    return this.raw.getContext('2d');
  }
  getCopiedCanvas(){
    const tcanvas = this.main.window.document.createElement('canvas');
    tcanvas.width = this.raw.width;
    tcanvas.height = this.raw.height;
    this.rcopy(tcanvas);
    return tcanvas;
  }
  resizeRect(x,y,w,h){
    const tcanvas = this.getCopiedCanvas();
    this.raw.width = w;
    this.raw.height = h;
    this.fill([255,255,255,0]);
    this.copyRect(tcanvas,w,h,x,y,0,0);
  }
  resize(width,height){
    const tcanvas = this.getCopiedCanvas();
    this.raw.width = width;
    this.raw.height = height;
    let x = 0;
    let y = 0;
    if (this.resizeType === Canvas.ResizeType.Center){
      x = (width - tcanvas.width) / 2;
      y = (height - tcanvas.height) / 2;
    }else if (this.resizeType === Canvas.ResizeType.TopLeft){
      // DO NOTHING
    }else if (this.resizeType === Canvas.ResizeType.TopRight){
      x = width - tcanvas.width;
    }else if (this.resizeType === Canvas.ResizeType.BottomLeft){
      y = height - tcanvas.height;
    }else if (this.resizeType === Canvas.ResizeType.BottomRight){
      x = width - tcanvas.width;
      y = height - tcanvas.height;
    }else{
      return false;
    }
    this.copyRect(tcanvas,tcanvas.width,tcanvas.height,0,0,x,y);
    return true;
  }
  setScalingType(type){
    this.scalingType = type;
  }
  scaling(width,height){
    if (width === this.raw.width && height === this.raw.height){
      return true;
    }
    const tcanvas = this.getCopiedCanvas();
    const tcontext = tcanvas.getContext('2d');
    this.raw.width = width;
    this.raw.height = height;
    this.fill([255,255,255,0])
    const context = this.raw.getContext('2d');
    const simg = tcontext.getImageData(0,0,tcanvas.width,tcanvas.height);
    const dimg = context.getImageData(0,0,this.raw.width,this.raw.height);
    const wscale = this.raw.width / tcanvas.width;
    const hscale = this.raw.height / tcanvas.height;
    const invWscale = 1 / wscale;
    const invHscale = 1 / hscale;
    const addrXY = (cv,x,y) => {
      return (y * cv.width + x) * 4;
    }
    if (this.scalingType === Canvas.ScalingType.None){
      context.save();
      context.imageSmoothingEnabled = false;
      context.globalAlpha = 1;
      context.globalCompositeOperation = Canvas.OverlapType.SourceOver;
      context.drawImage(tcanvas,0,0,tcanvas.width,tcanvas.height,0,0,this.raw.width,this.raw.height);
      context.restore();
    }else if (this.scalingType === Canvas.ScalingType.Smoothing){
      context.save();
      context.imageSmoothingEnabled = true;
      context.globalAlpha = 1;
      context.globalCompositeOperation = Canvas.OverlapType.SourceOver;
      context.drawImage(tcanvas,0,0,tcanvas.width,tcanvas.height,0,0,this.raw.width,this.raw.height);
      context.restore();
    }else if (this.scalingType === Canvas.ScalingType.Nearest){
      for(let y = 0; y < this.raw.height; y++){
        for(let x = 0; x < this.raw.width; x++){
          let cx0 = Math.floor((x / wscale) + 0.5);
          let cy0 = Math.floor((y / hscale) + 0.5);
          if (cx0 < 0){
            cx0 = 0;
          }
          if (cy0 < 0){
            cy0 = 0;
          }
          if (cx0 >= tcanvas.width){
            cx0 = tcanvas.width - 1;
          }
          if (cy0 >= tcanvas.height){
            cy0 = tcanvas.height - 1;
          }
          const index = (cy0 * tcanvas.width + cx0) * 4;
          const dindex = (y * this.raw.width + x) * 4;
          dimg.data[dindex] = simg.data[index];
          dimg.data[dindex + 1] = simg.data[index + 1];
          dimg.data[dindex + 2] = simg.data[index + 2];
          dimg.data[dindex + 3] = simg.data[index + 3];
        }
      }
      context.putImageData(dimg,0,0);
    }else if (this.scalingType === Canvas.ScalingType.Bilinear){
      // https://github.com/rgba-image/bilinear/blob/master/src/index.ts (MIT License)
      const inerpolate = (k, kMin,vMin,kMax,vMax) => {
        return (kMin == kMax) ? vMin : Math.round( ( k - kMin ) * vMax + ( kMax - k ) * vMin );
      }
      const assign = (destIndex,sx,xMin,xMax,y,yMin,yMax) => {
        let minIndex = addrXY(tcanvas,xMin,yMin);
        let maxIndex = addrXY(tcanvas,xMax,yMin);
        const vMin0 = inerpolate(sx,xMin,simg.data[minIndex],xMax,simg.data[maxIndex]);
        const vMin1 = inerpolate(sx,xMin,simg.data[minIndex + 1],xMax,simg.data[maxIndex + 1]);
        const vMin2 = inerpolate(sx,xMin,simg.data[minIndex + 2],xMax,simg.data[maxIndex + 2]);
        const vMin3 = inerpolate(sx,xMin,simg.data[minIndex + 3],xMax,simg.data[maxIndex + 3]);
        if (yMax == yMin){
          dimg.data[destIndex+0] = vMin0;
          dimg.data[destIndex+1] = vMin1;
          dimg.data[destIndex+2] = vMin2;
          dimg.data[destIndex+3] = vMin3;
        }else{
          minIndex = addrXY(tcanvas,xMin,yMax);
          maxIndex = addrXY(tcanvas,xMax,yMax);
          const vMax0 = inerpolate(sx,xMin,simg.data[minIndex],xMax,simg.data[maxIndex]);
          const vMax1 = inerpolate(sx,xMin,simg.data[minIndex + 1],xMax,simg.data[maxIndex + 1]);
          const vMax2 = inerpolate(sx,xMin,simg.data[minIndex + 2],xMax,simg.data[maxIndex + 2]);
          const vMax3 = inerpolate(sx,xMin,simg.data[minIndex + 3],xMax,simg.data[maxIndex + 3]);
          dimg.data[destIndex+0] = inerpolate(y,yMin,vMin0,yMax,vMax0);
          dimg.data[destIndex+1] = inerpolate(y,yMin,vMin1,yMax,vMax1);
          dimg.data[destIndex+2] = inerpolate(y,yMin,vMin2,yMax,vMax2);
          dimg.data[destIndex+3] = inerpolate(y,yMin,vMin3,yMax,vMax3);
        }
      }
      for(let y = 0; y < this.raw.height; y++){
        const srcY = y * invHscale;
        const yMin = srcY < 0 ? 0 : Math.trunc(srcY);
        const yMax = Math.min(Math.ceil(srcY),tcanvas.height - 1);
        for(let x = 0; x < this.raw.width; x++){
          const srcX = x * invWscale;
          const xMin = srcX < 0 ? 0 : Math.trunc(srcX);
          const xMax = Math.min(Math.ceil(srcX),tcanvas.width - 1);
          const addr = addrXY(this.raw,x,y);
          assign(addr,srcX,xMin,xMax,srcY,yMin,yMax);
        }
      }
      context.putImageData(dimg,0,0);
    }else if (this.scalingType === Canvas.ScalingType.Bicubic){
      // https://www.rainorshine.asia/2013/04/03/post2351.html
      const bicubicWeight = (d) => {
        if (d < 1){
          return 1 - 2 * d * d + d * d * d;
        }else if (d < 2){
          return 4 - 8 * d + 5 * d * d - d * d * d;
        }else{
          return 0;
        }
      }
      const trimByte = (v) => {
        return Math.min(255,Math.max(0,Math.round(v)));
      }
      for(let iy = 0; iy < this.raw.height; iy++){
        for(let ix = 0; ix < this.raw.width; ix++){
          const wfx = invWscale * ix;
          const wfy = invHscale * iy;
          const x = Math.trunc(wfx);
          const y = Math.trunc(wfy);
          let r = 0;
          let g = 0;
          let b = 0;
          let a = 0;
          for(let jy = y - 1; jy <= y + 2; jy++){
            for(let jx = x - 1; jx <= x + 2; jx++){
              const w = bicubicWeight(Math.abs(wfx - jx)) * bicubicWeight(Math.abs(wfy - jy));
              if (w === 0){
                continue;
              }
              let sx = (jx > tcanvas.width-1) ? x: jx;
              let sy = (jy > tcanvas.height-1) ? y: jy;
              sx = (sx < 0) ? 0: sx;
              sy = (sy < 0) ? 0: sy;
              const addr = addrXY(tcanvas,sx,sy);
              r += simg.data[addr] * w;
              g += simg.data[addr + 1] * w;
              b += simg.data[addr + 2] * w;
              a += simg.data[addr + 3] * w;
            }
          }
          const addr = addrXY(this.raw,ix,iy);
          dimg.data[addr] = trimByte(r);
          dimg.data[addr + 1] = trimByte(g);
          dimg.data[addr + 2] = trimByte(b);
          dimg.data[addr + 3] = trimByte(a);
        }
      }
      context.putImageData(dimg,0,0);
    }else{
      return false;
    }
    return true;
  }
  rateScaling(rate){
    return this.scaling(this.raw.width * rate,this.raw.height * rate);
  }
  move(x,y){
    if (x === 0 && y === 0){
      return true;
    }
    if (this.raw.width + x <= 0 || this.raw.height + y <= 0){
      this.raw.width = 1;
      this.raw.height = 1;
      this.fill([255,255,255,0]);
      return true;
    }
    const tcanvas = this.getCopiedCanvas();
    this.raw.width = tcanvas.width+x;
    this.raw.height = tcanvas.height+y;
    this.copyRect(tcanvas,tcanvas.width,tcanvas.height,0,0,x,y);
  }
  getFitRect(){
    let sx = null;
    let sy = null;
    let ex = null;
    let ey = null;
    const context = this.raw.getContext('2d');
    const img = context.getImageData(0,0,this.raw.width,this.raw.height);
    for(let j = 0; j < this.raw.height; j++){
      let tminx = null;
      let tmaxx = null;
      for(let i = 0; i < this.raw.width; i++){
        const index = (j * this.raw.width + i) * 4;
        if (img.data[index + 3] !== 0){
          if (tminx === null){
            tminx = i;
          }
          tmaxx = i;
          if (sy === null){
            sy = j;
          }
          ey = j;
        }
      }
      if (tminx !== null){
        if (sx === null){
          sx = tminx;
        }else{
          if (tminx < sx){
            sx = tminx;
          }
        }
        if (ex === null){
          ex = tmaxx;
        }else{
          if (tmaxx > ex){
            ex = tmaxx;
          }
        }
      }
    }
    if (sx === null || sy === null || ex === null || ey === null){
      return null;
    }
    if (sx >= ex || sy >= ey){
      return null;
    }
    return {
      x: sx,
      y: sy,
      w: ex - sx,
      h: ey - sy,
    };
  }
  fit(){
    const rect = this.getFitRect();
    if (rect === null){
      this.resize(1,1);
      this.fill([255,255,255,0]);
    }else{
      this.resizeRect(rect.x,rect.y,rect.w,rect.h);
    }
  }
  rotate(centerX,centerY,angle){
    const tcanvas = this.getCopiedCanvas();
    this.raw.width = tcanvas.width;
    this.raw.height = tcanvas.height;
    const context = this.raw.getContext('2d');
    context.save();
    context.translate(centerX,centerY);
    context.rotate(angle * Math.PI / 180);
    context.drawImage(tcanvas,-centerX,-centerY);
    context.restore();
  }
  rotateCenter(angle){
    return this.rotate(this.raw.width / 2,this.raw.height / 2,angle);
  }
  rotateAutosize(angle,opt){
    angle = angle % 360;
    if (angle === 0){
      return;
    }
    if (!opt){
      opt = {};
    }
    const tcanvas = this.getCopiedCanvas();
    const once = opt.once || false;
    if (!once && angle === 180){
      this.raw.width = tcanvas.width;
      this.raw.height = tcanvas.height;
      const context = this.raw.getContext('2d');
      context.save();
      context.scale(-1,-1);
      context.drawImage(tcanvas,-tcanvas.width,-tcanvas.height);
      context.restore();
      return;
    }
    if (!once && (angle === 90 || angle === 270)){
      this.raw.width = tcanvas.height;
      this.raw.height = tcanvas.width;
      const context = this.raw.getContext('2d');
      const timg = tcanvas.getContext('2d').getImageData(0,0,tcanvas.width,tcanvas.height);
      const img = this.raw.getContext('2d').getImageData(0,0,this.raw.width,this.raw.height);
      for(let j = 0; j < this.raw.height; j++){
        for(let i = 0; i < this.raw.width; i++){
          if (angle === 90){
            const index = (j * this.raw.width + i) * 4;
            const tindex = ((this.raw.width - i - 1) * tcanvas.width + j) * 4;
            img.data[index] = timg.data[tindex];
            img.data[index + 1] = timg.data[tindex + 1];
            img.data[index + 2] = timg.data[tindex + 2];
            img.data[index + 3] = timg.data[tindex + 3];
          }else{
            const index = (j * this.raw.width + i) * 4;
            const tindex = (i * tcanvas.width + (this.raw.height - j - 1)) * 4;
            img.data[index] = timg.data[tindex];
            img.data[index + 1] = timg.data[tindex + 1];
            img.data[index + 2] = timg.data[tindex + 2];
            img.data[index + 3] = timg.data[tindex + 3];
          }
        }
      }
      context.putImageData(img,0,0);
      return;
    }
    this.raw.width = tcanvas.width*2;
    this.raw.height = tcanvas.height*2;
    this.fill([255,255,255,0]);
    const context = this.raw.getContext('2d');
    context.save();
    context.translate(tcanvas.width,tcanvas.height);
    context.rotate(angle * Math.PI / 180);
    context.drawImage(tcanvas,-tcanvas.width / 2,-tcanvas.height / 2);
    context.restore();
    this.fit();
  }
  flipHorizontal(){
    const tcanvas = this.getCopiedCanvas();
    this.raw.width = tcanvas.width;
    this.raw.height = tcanvas.height;
    const context = this.raw.getContext('2d');
    context.save();
    context.scale(-1,1);
    context.drawImage(tcanvas,-tcanvas.width,0);
    context.restore();
  }
  flipVertical(){
    const tcanvas = this.getCopiedCanvas();
    this.raw.width = tcanvas.width;
    this.raw.height = tcanvas.height;
    const context = this.raw.getContext('2d');
    context.save();
    context.scale(1,-1);
    context.drawImage(tcanvas,0,-tcanvas.height);
    context.restore();
  }
  colorFilter(filter){
    const context = this.raw.getContext('2d');
    const img = context.getImageData(0,0,this.raw.width,this.raw.height);
    for(let i = 0; i < img.data.length; i += 4){
      const color = filter([img.data[i],img.data[i + 1],img.data[i + 2],img.data[i + 3]]);
      img.data[i] = color[0];
      img.data[i + 1] = color[1];
      img.data[i + 2] = color[2];
      img.data[i + 3] = color[3];
    }
    context.putImageData(img,0,0);
  }
  colorFilterGray(){
    this.colorFilter((color) => {
      const gray = 0.299 * color[0] + 0.587 * color[1] + 0.114 * color[2];
      return [gray,gray,gray,color[3]];
    });
  }
  colorFilterSepia(){
    this.colorFilter((color) => {
      const r = 0.393 * color[0] + 0.769 * color[1] + 0.189 * color[2];
      const g = 0.349 * color[0] + 0.686 * color[1] + 0.168 * color[2];
      const b = 0.272 * color[0] + 0.534 * color[1] + 0.131 * color[2];
      return [r,g,b,color[3]];
    });
  }
  getBlurHash(){
    const canvas = this.main.window.document.createElement('canvas');
    const context = canvas.getContext('2d');
    const scale = 100 / Math.max(this.raw.width, this.raw.height);
    canvas.width = Math.round(this.raw.width * scale);
    canvas.height = Math.round(this.raw.height * scale);
    context.drawImage(this.raw, 0, 0, canvas.width, canvas.height);
    const pixels = context.getImageData(0, 0, canvas.width, canvas.height);
    return self.vendor.blurhash.encode(pixels.data,pixels.width,pixels.height,4,3);
  }
  setBlurHash(hash){
    const w = this.raw.width;
    const h = this.raw.height;
    const scale = 100 / Math.max(this.raw.width, this.raw.height);
    this.raw.width = Math.round(this.raw.width * scale);
    this.raw.height = Math.round(this.raw.height * scale);
    const imgd = self.vendor.blurhash.decode(hash,this.raw.width,this.raw.height,1);
    const context = this.raw.getContext('2d');
    const pixels = context.getImageData(0, 0, this.raw.width, this.raw.height);
    for(let i = 0; i < imgd.length; i ++){
      pixels.data[i] = imgd[i];
    }
    context.putImageData(pixels,0,0);
    this.scaling(w,h);
  }
  getThumbHash(){
    const canvas = this.main.window.document.createElement('canvas');
    const context = canvas.getContext('2d');
    const scale = 100 / Math.max(this.raw.width, this.raw.height);
    canvas.width = Math.round(this.raw.width * scale);
    canvas.height = Math.round(this.raw.height * scale);
    context.drawImage(this.raw, 0, 0, canvas.width, canvas.height);
    const pixels = context.getImageData(0, 0, canvas.width, canvas.height);
    const binaryThumbHash = self.vendor.ThumbHash.rgbaToThumbHash(pixels.width, pixels.height, pixels.data);
    const binaryToBase64 = binary => btoa(String.fromCharCode(...binary))
    return binaryToBase64(binaryThumbHash);
  }
  setThumbHash(hash){
    const w = this.raw.width;
    const h = this.raw.height;
    const base64ToBinary = base64 => new Uint8Array(atob(base64).split('').map(x => x.charCodeAt(0)))
    const imgd = self.vendor.ThumbHash.thumbHashToRGBA(base64ToBinary(hash));
    this.raw.width = imgd.w;
    this.raw.height = imgd.h;
    const context = this.raw.getContext('2d');
    const pixels = context.getImageData(0, 0, this.raw.width, this.raw.height);
    for(let i = 0; i < imgd.rgba.length; i ++){
      pixels.data[i] = imgd.rgba[i];
    }
    context.putImageData(pixels, 0, 0);
    this.scaling(w,h);
  }
  loadLocalImage(){
    const input = this.main.window.document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e) => {
      let file = null;
      if (e.target.files){
        file = e.target.files[0];
      }else if (e.dataTransfer.files){
        file = e.dataTransfer.files[0];
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const context = this.raw.getContext('2d');
          this.raw.width = img.width;
          this.raw.height = img.height;
          context.save();
          context.globalAlpha = 1;
          context.globalCompositeOperation = Canvas.OverlapType.Copy;
          context.drawImage(img,0,0);
          context.restore();
        };
        img.onerror = () => {
          alert('ERROR\nnot image file')
        }
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    };
    input.click();
  }
}

// ================================================
// module: browser , from: clipcache.js
// ================================================

// ================================================
// module: browser , from: color.js
// ================================================
const Color = self.Color = class Color {
  static colorToArray(color, defaultColor){
    if (defaultColor === null || defaultColor === undefined){
      defaultColor = [255,255,255,0];
    }
    if (color === null || color === undefined){
      return defaultColor;
    }else if (color instanceof Array){
      if (color.length == 3){
        color.push(1);
      }
      return color.map((v) => parseInt(v));
    }else if (typeof color === 'string'){
      if (color.startsWith('rgba(')){
        color = color.replace('rgba(','').replace(')','');
      }else if (color.startsWith('rgb(')){
        color = color.replace('rgb(','').replace(')',',1');
      }else{
        return defaultColor;
      }
      const c = color.split(',');
      if (c.length == 3){
        c.push(1);
      }
      return c.map((v) => parseInt(v));
    }else{
      return defaultColor;
    }
  }
}

// ================================================
// module: browser , from: colorClass.js
// ================================================
const ColorClass = self.ColorClass = class ColorClass {
  constructor(theme = "default"){
    this.themeName = theme;
    if (theme === undefined || theme === null){
      this.theme = null;
    }else if (typeof theme === "string"){
      for (let themeName in colorTheme){
        if (!themeName.charAt(0).match(/[A-Z]/)) continue;
        if (themeName.toLowerCase() == theme.toLowerCase()){
          this.theme = colorTheme[themeName];
          break;
        }
      }
      if (!this.theme) this.theme = colorTheme.Default;  
    }else{
      this.theme = theme;
    }
    this.classBaseName = "";
    this.classInstanceName = "";
  }
  setClassBaseName(name){
    this.classBaseName = name;
  }
  setClassInstanceName(name){
    this.classInstanceName = name;
  }
  getColorname2Name(colorName){
    if (colorName === undefined || colorName === null){
      return '';
    }
    return colorName
      .replace(/Color$/g, '')
      .replace(/[A-Z]/g, function(s){
        return "_" + s.toLowerCase();
      })
      .replace(/^_/,'');
  }
  setColor(object,name,color){
    if (color === undefined || color === null){
      color = '';
    }
    if (object.style){
      if (name.toLowerCase().endsWith("backgroundcolor")){
        if (object.style.backgroundColor !== undefined){
          object.style.backgroundColor = color;
        }
      }else if (name.match(/Border((?:[A-Z][a-z]+)*)Color$/)){
        let m = name.match(/Border((?:[A-Z][a-z]+)*)Color$/);
        let s = m[0];
        if (object.style["border" + s + "Color"] !== undefined){
          object.style["border" + s + "Color"] = color;
        }
      }else if (name.toLowerCase().endsWith("accentcolor")){
        if (object.style.accentColor !== undefined){
          object.style.accentColor = color;
        }
      }else if (name.toLowerCase().endsWith("caretcolor")){
        if (object.style.caretColor !== undefined){
          object.style.caretColor = color;
        }
      }else if (name.toLowerCase().endsWith("columnrulecolor")){
        if (object.style.columnRuleColor !== undefined){
          object.style.columnRuleColor = color;
        }
      }else if (name.toLowerCase().endsWith("lightingcolor")){
        if (object.style.lightingColor !== undefined){
          object.style.lightingColor = color;
        }
      }else if (name.toLowerCase().endsWith("outlinecolor")){
        if (object.style.outlineColor !== undefined){
          object.style.outlineColor = color;
        }
      }else if (name.toLowerCase().endsWith("scrollbarcolor")){
        if (object.style.scrollbarColor !== undefined){
          object.style.scrollbarColor = color;
        }
      }else if (name.toLowerCase().endsWith("stopcolor")){
        if (object.style.stopColor !== undefined){
          object.style.stopColor = color;
        }
      }else if (name.match(/Text((?:[A-Z][a-z]+)*)Color$/)){
        let m = name.match(/Text((?:[A-Z][a-z]+)*)Color$/);
        let s = m[0];
        if (object.style["text" + s + "Color"] !== undefined){
          object.style["text" + s + "Color"] = color;
        }
      }else{
        if (object.style.color !== undefined){
          object.style.color = color;
        }
      }
    }
  }
  removeClass(object,colorName,id){
    const name = this.getColorname2Name(colorName);
    let className = this.classBaseName + "-" + name;
    let instanceName = className + "-" + this.classInstanceName;
    if (object.classList !== undefined){
      object.classList.remove(className);
      object.classList.remove(instanceName);
      if (id !== undefined && id !== null){
        let instanceNameWithId = instanceName + "-" + id;
        object.classList.remove(instanceNameWithId);
      }
    }
  }
  removeColorClass(object,colorName,id){
    this.removeClass(object,colorName,id);
    this.setColor(object,colorName,'');
  }
  setClass(object,colorName,id){
    const name = this.getColorname2Name(colorName);
    let className = this.classBaseName + "-" + name;
    let instanceName = className + "-" + this.classInstanceName;
    if (object.classList !== undefined){
      if (!object.classList.contains(className)){
        object.classList.add(className);
      }
      if (!object.classList.contains(instanceName)){
        object.classList.add(instanceName);
      }
      if (id !== undefined && id !== null){
        let instanceNameWithId = instanceName + "-" + id;
        if (!object.classList.contains(instanceNameWithId)){
          object.classList.add(instanceNameWithId);
        }
      }
    }
  }
  setColorClass(object,colorName,id){
    let color = this.theme[colorName];
    this.setClass(object,colorName,id);
    this.setColor(object,colorName,color);
  }
  getColor(colorName){
    return this.theme[colorName];
  }
}

// ================================================
// module: browser , from: layer.js
// ================================================
const Layer = self.Layer = class Layer {
  static LayerTransformType = {
    Position: 1,
    Angle: 2,
    Scale: 3,
  };

  static currentLayerId = 0;
  constructor(main,width,height,opt) {
    Layer.currentLayerId++;
    this.id = Layer.currentLayerId;
    if (!opt) {
      opt = {};
    }
    this.main = main;
    this.aboveLayers = [];
    this.belowLayers = [];
    this.layerChain = {
      last: null,
      next: null,
    }
    this.position = { x: 0, y: 0 };
    this.angle = 0;
    this.scale = 1;
    this.canvas = new Canvas(main,width,height);
    this.visible = true;
    this.syncPositionLayers = [];
    this.syncAngleLayers = [];
    this.syncScaleLayers = [];
    this.writeClip = false;
    if (opt.writeClip === true) {
      this.writeClip = opt.writeClip;
    }
  }
  addSyncPositionLayer(layer) {
    this.syncPositionLayers.push(layer);
  }
  removeSyncPositionLayer(layer) {
    this.syncPositionLayers = this.syncPositionLayers.filter(l => l !== layer);
  }
  addSyncAngleLayer(layer) {
    this.syncAngleLayers.push(layer);
  }
  removeSyncAngleLayer(layer) {
    this.syncAngleLayers = this.syncAngleLayers.filter(l => l !== layer);
  }
  addSyncScaleLayer(layer) {
    this.syncScaleLayers.push(layer);
  }
  removeSyncScaleLayer(layer) {
    this.syncScaleLayers = this.syncScaleLayers.filter(l => l !== layer);
  }
  setPosition(x, y) {
    this.position.x = x;
    this.position.y = y;
    for (let layer of this.syncPositionLayers) {
      layer.setPosition(x, y);
    }
  }
  movePosition(x, y) {
    this.position.x += x;
    this.position.y += y;
    for (let layer of this.syncPositionLayers) {
      layer.movePosition(x, y);
    }
  }
  setAngle(angle) {
    this.angle = angle % 360;
    for (let layer of this.syncAngleLayers) {
      layer.setAngle(this.angle);
    }
  }
  setScale(scale) {
    this.scale = scale;
    for (let layer of this.syncScaleLayers) {
      layer.setScale(this.scale);
    }
  }
  getAngle() {
    return this.angle;
  }
  getPosition() {
    return structuredClone(this.position);
  }
  getScale() {
    return this.scale;
  }
  setVisible(visible) {
    this.visible = visible;
  }
  getVisible() {
    return this.visible;
  }
  addAboveLayer(layer) {
    this.aboveLayers.push(layer);
  }
  addBelowLayer(layer) {
    this.belowLayers.push(layer);
  }
  removeAboveLayer(layer) {
    this.aboveLayers = this.aboveLayers.filter(l => l !== layer);
  }
  removeBelowLayer(layer) {
    this.belowLayers = this.belowLayers.filter(l => l !== layer);
  }
  getNextLayer() {
    return this.layerChain.next;
  }
  getLastLayer() {
    return this.layerChain.last;
  }
  getStartLayer() {
    let startLayer = this;
    while (startLayer.layerChain.last) {
      startLayer = startLayer.layerChain.last;
    }
    return startLayer;
  }
  getEndLayer() {
    let endLayer = this;
    while (endLayer.layerChain.next) {
      endLayer = endLayer.layerChain.next;
    }
    return endLayer;
  }
  insertNextLayer(layer) {
    if (this.layerChain.next) {
      this.layerChain.next.layerChain.last = layer;
      layer.layerChain.next = this.layerChain.next;
    }
    this.layerChain.next = layer;
    layer.layerChain.last = this;
  }
  insertLastLayer(layer) {
    if (this.layerChain.last) {
      this.layerChain.last.layerChain.next = layer;
      layer.layerChain.last = this.layerChain.last;
    }
    this.layerChain.last = layer;
    layer.layerChain.next = this;
  }
  deleteNextLayer() {
    if (this.layerChain.next) {
      const nextLayer = this.layerChain.next;
      this.layerChain.next = this.layerChain.next.layerChain.next;
      this.layerChain.next.layerChain.last = this;
      nextLayer.layerChain.next = null;
      nextLayer.layerChain.last = null;
    }
  }
  deleteLastLayer() {
    if (this.layerChain.last) {
      const lastLayer = this.layerChain.last;
      this.layerChain.last = this.layerChain.last.layerChain.last;
      this.layerChain.last.layerChain.next = this;
      lastLayer.layerChain.next = null;
      lastLayer.layerChain.last = null;
    }
  }
  getTopLayers() {
    let topLayers = [];
    if (this.aboveLayers.length === 0) {
      topLayers.push(this);
      return topLayers;
    }
    for (let layer of this.aboveLayers) {
      if (layer instanceof Layer) {
        topLayers = topLayers.concat(layer.getTopLayers());
      } else {
        // DO NOTHING
      }
    }
    return topLayers;
  }
  outputToCanvasFromCanvas(srcCanvas,destCanvas,diffPos,scale,opt) {
    if (!opt) {
      opt = {};
    }
    const crect = srcCanvas.getRect();
    if (opt.diffPos) {
      if (opt.diffPos.x) {
        diffPos.x = opt.diffPos.x;
      }
      if (opt.diffPos.y) {
        diffPos.y = opt.diffPos.y;
      }
    }
    let destHTMLCanvas = null;
    if (destCanvas instanceof Canvas) {
      destHTMLCanvas = destCanvas.getHTMLCanvas();
    }else if (destCanvas instanceof HTMLCanvasElement){
      destHTMLCanvas = destCanvas;
    }else{
      // DO NOTHING
    }
    const context = destHTMLCanvas.getContext('2d');
    context.save();
    context.imageSmoothingEnabled = false;
    context.globalAlpha = srcCanvas.globalAlpha;
    context.globalCompositeOperation = srcCanvas.globalCompositeOperation;
    context.translate(diffPos.x,diffPos.y);
    context.scale(scale,scale);
    context.drawImage(srcCanvas.getHTMLCanvas(),0,0,crect.w,crect.h,0,0,crect.w,crect.h);
    context.restore();
  }
  outputToCanvas(canvas,opt) {
    this.outputToCanvasFromCanvas(this.canvas,canvas,structuredClone(this.position),this.scale,opt);
  }
  outputBelowLayers(canvas,opt) {
    for (let layer of this.belowLayers) {
      if (layer instanceof Layer) {
        layer.outputCurrentLayer(canvas,opt);
      } else {
        // DO NOTHING
      }
    }
  }
  clearCanvas(canvas, opt) {
    if (!opt) {
      opt = {};
    }
    if (opt.clearCanvas) {
      let color = [255,255,255,0];
      if (opt.clearColor) {
        color = Color.colorToArray(opt.clearColor);
      }
      if (canvas instanceof Canvas) {
        canvas.fill(color);
      }else if (canvas instanceof HTMLCanvasElement){
        const colorAry = Color.colorToArray(color);
        const context = canvas.getContext('2d');
        const contextimg = context.getImageData(0,0,canvas.width,canvas.height);
        for(let i = 0; i < contextimg.data.length; i += 4){
          contextimg.data[i] = colorAry[0];
          contextimg.data[i + 1] = colorAry[1];
          contextimg.data[i + 2] = colorAry[2];
          contextimg.data[i + 3] = colorAry[3];
        }
        context.putImageData(contextimg,0,0);
      }else{
        // DO NOTHING
      }
    }
  }
  outputCurrentLayer(canvas, opt) {
    if (!opt) {
      opt = {};
    }
    if (opt.clearCanvas) {
      let color = [255,255,255,0];
      if (opt.clearColor) {
        color = Color.colorToArray(opt.clearColor);
      }
      this.clearCanvas(canvas, opt);
    }
    if (this.visible === true) {
      let crect = {
        x:0,y:0,w:0,h:0
      };
      if (canvas instanceof Canvas) {
        crect = canvas.getRect();
      }else if (canvas instanceof HTMLCanvasElement){
        crect.w = canvas.width;
        crect.h = canvas.height;
      }
      let s = 0;
      let sw = 0;
      let sh = 0;
      if (this.angle === 0) {
        // DO NOTHING
      }else {
        const tempw = crect.w;
        const temph = crect.h;
        sw = Math.ceil(tempw * Math.abs(Math.cos(this.angle * Math.PI / 180)) + temph * Math.abs(Math.sin(this.angle * Math.PI / 180)));
        sh = Math.ceil(tempw * Math.abs(Math.sin(this.angle * Math.PI / 180)) + temph * Math.abs(Math.cos(this.angle * Math.PI / 180)));
        s = sw + sh;
      }
      //crect.w += Math.abs(this.position.x);
      //crect.h += Math.abs(this.position.y);
      const tcanvas = new Canvas(this.main,crect.w,crect.h);
      if (this.writeClip === true) {
        tcanvas.resizeRect(0,0,this.canvas.getRect().w,this.canvas.getRect().h);
      }
      this.outputBelowLayers(tcanvas,{});
      if (this.angle === 0) {
        this.outputToCanvasFromCanvas(this.canvas,tcanvas,{x:0,y:0},1,{});
        tcanvas.rotateCenter(this.angle);
        this.outputToCanvasFromCanvas(tcanvas,canvas,structuredClone(this.position),this.scale,{});
      }else {
        const ow = tcanvas.getRect().w;
        const oh = tcanvas.getRect().h;
        tcanvas.setResizeType(Canvas.ResizeType.Center);
        tcanvas.resize(s*2,s*2);
        this.outputToCanvasFromCanvas(this.canvas,tcanvas,{x:s-this.canvas.getRect().w/2,y:s-this.canvas.getRect().h/2},1,{});
        tcanvas.rotateCenter(this.angle);
        tcanvas.resizeRect(s-this.canvas.getRect().w/2-this.position.x,s-this.canvas.getRect().h/2-this.position.y,ow,oh);
        if (this.writeClip === true) {
          this.outputToCanvasFromCanvas(tcanvas,canvas,{x:0,y:0},this.scale,{});
        }else{
          this.outputToCanvasFromCanvas(tcanvas,canvas,{x:0,y:0},this.scale,{});
        }
      }
    }
    if (this.layerChain.next) {
      this.layerChain.next.outputCurrentLayer(canvas);
    }
  }
  outputCurrentFullLayres(canvas,opt) {
    this.getStartLayer().outputCurrentLayer(canvas,opt);
  }
  outputFullLayres(canvas) {
    const topLayers = this.getTopLayers();
    for (let layer of topLayers) {
      layer.outputCurrentFullLayres(canvas);
    }
  }
  getCanvas() {
    return this.canvas;
  }
  getLayerList(target,exceptList) {
    if (target == null){
      return null;
    }
    if (exceptList === undefined || exceptList === null){
      exceptList = [];
    }
    if (target === this){
      if (exceptList.indexOf(this) !== -1){
        return [];
      }
      return [this];
    }
    if (this.belowLayers.length > 0){
      for (let layer of this.belowLayers){
        if (layer instanceof Layer){
          const r = layer.getLayerList(target,exceptList);
          if (r != null){
            if (exceptList.indexOf(this) !== -1){
              return r;
            }
            r.unshift(this);
            return r;
          }
        }
      }
    }
    if (this.layerChain.next){
      const r = this.layerChain.next.getLayerList(target,exceptList);
      if (r != null){
        if (exceptList.indexOf(this) !== -1){
          return r;
        }
        r.unshift(this);
        return r;
      }
    }
    return null;
  }
  getLayerTransform(){
    if (this.position.x === 0 && this.position.y === 0 && this.angle === 0 && this.scale === 1){
      return [];
    }
    let r = [];
    if (this.angle !== 0){
      r.push({
        type: Layer.LayerTransformType.Angle,
        x: this.canvas.getRect().w/2,
        y: this.canvas.getRect().h/2,
        angle: this.angle,
        layer: this,
      });
    }
    if (this.position.x !== 0 || this.position.y !== 0){
      r.push({
        type: Layer.LayerTransformType.Position,
        x: this.position.x,
        y: this.position.y,
        layer: this,
      });
    }
    if (this.scale !== 1){
      r.push({
        type: Layer.LayerTransformType.Scale,
        scale: this.scale,
        layer: this,
      });
    }
    return r;
  }
  getLayerTransformList(layerList){
    if (layerList == null){
      return null;
    }
    let transformList = [];
    for (let layer of layerList){
      const t = layer.getLayerTransform();
      if (t != null){
        transformList = transformList.concat(t);
      }
    }
    return transformList;
  }
  testFillRect(Layer,exceptList){
    const transformList = this.getLayerTransformList(Layer.getLayerList(this,exceptList));
    const ctx = this.getCanvas().getHTMLCanvas().getContext('2d');
    ctx.save();
    for (let transform of transformList){
      if (transform.type === Layer.LayerTransformType.Position){
        ctx.translate(-transform.x,-transform.y);
      }else if (transform.type === Layer.LayerTransformType.Angle){
        ctx.translate(transform.x,transform.y);
        ctx.rotate(-transform.angle * Math.PI / 180);
        ctx.translate(-transform.x,-transform.y);
      }else if (transform.type === Layer.LayerTransformType.Scale){
        ctx.scale(1/transform.scale,1/transform.scale);
      }
    }
    ctx.fillStyle = 'rgb(255,0,0)';
    ctx.fillRect(100,200,10,20);
    ctx.restore();
  }
}

// ================================================
// module: browser , from: titlebar.js
// ================================================
const TitleBar = self.TitleBar = class TitleBar {
  static currentTitlebarId = 0;
  constructor(main,parentObj,options) {
    TitleBar.currentTitlebarId++;
    this.id = TitleBar.currentTitlebarId;
    if (!options) {
      options = {};
    }
    this.main = main;
    this.visible = true;
    this.parentObj = parentObj || main.targetObj;
    this.height = 20;
    this.menuIcon = options.menuIcon || '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#5f6368"><path d="M144-264v-72h672v72H144Zm0-180v-72h672v72H144Zm0-180v-72h672v72H144Z"/></svg>';
    this.title = options.title || "";
    this.closeIcon = options.closeIcon || '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#5f6368"><path d="m291-240-51-51 189-189-189-189 51-51 189 189 189-189 51 51-189 189 189 189-51 51-189-189-189 189Z"/></svg>';
    this.fullscrIcon = options.fullscrIcon || '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#5f6368"><path d="M168-192q-29.7 0-50.85-21.16Q96-234.32 96-264.04v-432.24Q96-726 117.15-747T168-768h624q29.7 0 50.85 21.16Q864-725.68 864-695.96v432.24Q864-234 842.85-213T792-192H168Zm0-72h624v-360H168v360Z"/></svg>';
    this.minIcon = options.minIcon || '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#5f6368"><path d="M288-144v-72h384v72H288Z"/></svg>';
    this.normalscrIcon = options.normalscrIcon || '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#5f6368"><path d="M312-312h480v-408H312v408Zm0 72q-29.7 0-50.85-21.15Q240-282.3 240-312v-480q0-29.7 21.15-50.85Q282.3-864 312-864h480q29.7 0 50.85 21.15Q864-821.7 864-792v480q0 29.7-21.15 50.85Q821.7-240 792-240H312ZM168-96q-29.7 0-50.85-21.15Q96-138.3 96-168v-552h72v552h552v72H168Zm144-696v480-480Z"/></svg>';

    if (options.color === undefined) {
      options.color = {};
    }
    this.color = {
      iconbgcolor: options.color.iconbgcolor || "WindowIconBackgroundColor",
      iconcolor: options.color.iconcolor || "WindowIconColor",
      iconhoverbgcolor: options.color.iconhoverbgcolor || "WindowIconHoverBackgroundColor",
      iconhovercolor: options.color.iconhovercolor || "WindowIconHoverColor",
      bgcolor: options.color.bgcolor || "WindowTitlebarBackgroundColor",
      color: options.color.color || "WindowTitlebarColor",
      topbgcolor: options.color.topbgcolor || "WindowTitlebarTopBackgroundColor",
      topcolor: options.color.topcolor || "WindowTitlebarTopColor",
    };

    this.showMenuIcon = options.showMenuIcon || true;
    this.showTitle = options.showTitle || true;
    this.showCloseIcon = options.showCloseIcon || true;
    this.showFullscrIcon = options.showFullscrIcon || true;
    this.showMinIcon = options.showMinIcon || true;
    if (options.onclick === undefined) {
      options.onclick = {};
    }
    this.onclick = {
      menu: options.onclick.menu || function(){},
      min: options.onclick.min || function(){},
      normalscr: options.onclick.normalscr || function(){},
      fullscr: options.onclick.fullscr || function(){},
      close: options.onclick.close || function(){},
      titlebar: options.onclick.titlebar || function(){},
    };
    if (options.ondblclick === undefined) {
      options.ondblclick = {};
    }
    this.ondblclick = {
      menu: options.ondblclick.menu || function(){},
      min: options.ondblclick.min || function(){},
      normalscr: options.ondblclick.normalscr || function(){},
      fullscr: options.ondblclick.fullscr || function(){},
      close: options.ondblclick.close || function(){},
      titlebar: options.ondblclick.titlebar || function(){},
    };
    if (options.onmouseover === undefined) {
      options.onmouseover = {};
    }
    this.onmouseover = {
      menu: options.onmouseover.menu || function(){},
      min: options.onmouseover.min || function(){},
      normalscr: options.onmouseover.normalscr || function(){},
      fullscr: options.onmouseover.fullscr || function(){},
      close: options.onmouseover.close || function(){},
      titlebar: options.onmouseover.titlebar || function(){},
    };
    if (options.onmouseout === undefined) {
      options.onmouseout = {};
    }
    this.onmouseout = {
      menu: options.onmouseout.menu || function(){},
      min: options.onmouseout.min || function(){},
      normalscr: options.onmouseout.normalscr || function(){},
      fullscr: options.onmouseout.fullscr || function(){},
      close: options.onmouseout.close || function(){},
      titlebar: options.onmouseout.titlebar || function(){},
    };
    if (options.onpointermove === undefined) {
      options.onpointermove = {};
    }
    this.onpointermove = {
      menu: options.onpointermove.menu || function(){},
      min: options.onpointermove.min || function(){},
      normalscr: options.onpointermove.normalscr || function(){},
      fullscr: options.onpointermove.fullscr || function(){},
      close: options.onpointermove.close || function(){},
      titlebar: options.onpointermove.titlebar || function(){},
    };
    if (options.ontouchstart === undefined) {
      options.ontouchstart = {};
    }
    this.ontouchstart = {
      menu: options.ontouchstart.menu || function(){},
      min: options.ontouchstart.min || function(){},
      normalscr: options.ontouchstart.normalscr || function(){},
      fullscr: options.ontouchstart.fullscr || function(){},
      close: options.ontouchstart.close || function(){},
      titlebar: options.ontouchstart.titlebar || function(){},
    };
    if (options.ontouchend === undefined) {
      options.ontouchend = {};
    }
    this.ontouchend = {
      menu: options.ontouchend.menu || function(){},
      min: options.ontouchend.min || function(){},
      normalscr: options.ontouchend.normalscr || function(){},
      fullscr: options.ontouchend.fullscr || function(){},
      close: options.ontouchend.close || function(){},
      titlebar: options.ontouchend.titlebar || function(){},
    };
    if (options.ontouchmove === undefined) {
      options.ontouchmove = {};
    }
    this.ontouchmove = {
      menu: options.ontouchmove.menu || function(){},
      min: options.ontouchmove.min || function(){},
      normalscr: options.ontouchmove.normalscr || function(){},
      fullscr: options.ontouchmove.fullscr || function(){},
      close: options.ontouchmove.close || function(){},
      titlebar: options.ontouchmove.titlebar || function(){},
    };
    this.titlebar = this.main.window.document.createElement("div");
    this.titlebar.style.width = "100%";
    this.titlebar.style.height = this.height + "px";
    this.main.colorClass.setColorClass(this.titlebar,this.color.bgcolor,this.id);
    this.main.colorClass.setColorClass(this.titlebar,this.color.color,this.id);
    this.main.colorClass.setClass(this.titlebar,this.color.topbgcolor,this.id);
    this.main.colorClass.setClass(this.titlebar,this.color.topcolor,this.id);
    this.titlebar.style.textAlign = "left";
    this.titlebar.style.padding = "0px";
    this.titlebar.style.margin = "0px";
    this.titlebar.style.border = "0px";
    this.titlebar.style.overflow = "hidden";
    this.titlebar.style.boxSizing = "border-box";
    this.titlebar.style.display = "flex";
    this.titlebar.draggable = false;
    this.leftitem = this.main.window.document.createElement("div");
    this.leftitem.style.width = "auto";
    this.leftitem.style.height = this.height + "px";
    this.leftitem.style.padding = "0px";
    this.leftitem.style.border = "0px";
    this.leftitem.style.overflow = "hidden";
    this.leftitem.style.boxSizing = "border-box";
    this.leftitem.style.textAlign = "left";
    this.leftitem.style.whiteSpace = "nowrap";
    this.leftitem.draggable = false;
    this.titlebar.appendChild(this.leftitem);
    this.menuitem = this.main.window.document.createElement("div");
    this.menuitem.style.width = "auto";
    this.menuitem.style.height = this.height + "px";
    this.menuitem.style.padding = "0px";
    this.menuitem.style.border = "0px";
    this.menuitem.style.overflow = "hidden";
    this.menuitem.style.boxSizing = "border-box";
    this.menuitem.style.textAlign = "left";
    this.menuitem.draggable = false;
    this.main.colorClass.setColorClass(this.menuitem,this.color.iconbgcolor,this.id);
    this.main.colorClass.setColorClass(this.menuitem,this.color.iconcolor,this.id);
    this.main.colorClass.setClass(this.menuitem,this.color.iconhoverbgcolor,this.id);
    this.main.colorClass.setClass(this.menuitem,this.color.iconhovercolor,this.id);
    this.menuitem.innerHTML = this.menuIcon;
    this.leftitem.appendChild(this.menuitem);
    this.titleitem = this.main.window.document.createElement("div");
    this.titleitem.style.width = "auto";
    this.titleitem.style.height = this.height + "px";
    this.titleitem.style.padding = "0px";
    this.titleitem.style.border = "0px";
    this.titleitem.style.textAlign = "left";
    this.titleitem.style.marginLeft = "2px";
    this.titleitem.style.marginRight = "2px";
    this.titleitem.style.overflow = "hidden";
    this.titleitem.style.boxSizing = "border-box";
    this.titleitem.style.fontSize = "14px";
    this.titleitem.style.whiteSpace = "nowrap";
    this.titleitem.draggable = false;
    this.main.colorClass.setColorClass(this.titleitem,this.color.bgcolor,this.id);
    this.main.colorClass.setColorClass(this.titleitem,this.color.color,this.id);
    this.titleitem.innerHTML = this.title;
    this.titlebar.appendChild(this.titleitem);
    this.rightitem = this.main.window.document.createElement("div");
    this.rightitem.style.width = "auto";
    this.rightitem.style.height = this.height + "px";
    this.rightitem.style.padding = "0px";
    this.rightitem.style.border = "0px";
    this.rightitem.style.overflow = "hidden";
    this.rightitem.style.boxSizing = "border-box";
    this.rightitem.style.textAlign = "right";
    this.rightitem.style.marginLeft = "auto";
    this.rightitem.style.whiteSpace = "nowrap";
    this.rightitem.style.display = "flex";
    this.rightitem.draggable = false;
    this.titlebar.appendChild(this.rightitem);
    this.minitem = this.main.window.document.createElement("div");
    this.minitem.style.width = "auto";
    this.minitem.style.height = this.height + "px";
    this.minitem.style.overflow = "hidden";
    this.minitem.draggable = false;
    this.main.colorClass.setColorClass(this.minitem,this.color.iconbgcolor,this.id);
    this.main.colorClass.setColorClass(this.minitem,this.color.iconcolor,this.id);
    this.main.colorClass.setClass(this.minitem,this.color.iconhoverbgcolor,this.id);
    this.main.colorClass.setClass(this.minitem,this.color.iconhovercolor,this.id);
    this.minitem.innerHTML = this.minIcon;
    this.rightitem.appendChild(this.minitem);
    this.normalscritem = this.main.window.document.createElement("div");
    this.normalscritem.style.width = "auto";
    this.normalscritem.style.height = this.height + "px";
    this.normalscritem.style.overflow = "hidden";
    this.normalscritem.innerHTML = this.normalscrIcon;
    this.normalscritem.draggable = false;
    this.main.colorClass.setColorClass(this.normalscritem,this.color.iconbgcolor,this.id);
    this.main.colorClass.setColorClass(this.normalscritem,this.color.iconcolor,this.id);
    this.main.colorClass.setClass(this.normalscritem,this.color.iconhoverbgcolor,this.id);
    this.main.colorClass.setClass(this.normalscritem,this.color.iconhovercolor,this.id);
    this.rightitem.appendChild(this.normalscritem);
    this.fullscritem = this.main.window.document.createElement("div");
    this.fullscritem.style.width = "auto";
    this.fullscritem.style.height = this.height + "px";
    this.fullscritem.style.overflow = "hidden";
    this.fullscritem.innerHTML = this.fullscrIcon;
    this.fullscritem.draggable = false;
    this.main.colorClass.setColorClass(this.fullscritem,this.color.iconbgcolor,this.id);
    this.main.colorClass.setColorClass(this.fullscritem,this.color.iconcolor,this.id);
    this.main.colorClass.setClass(this.fullscritem,this.color.iconhoverbgcolor,this.id);
    this.main.colorClass.setClass(this.fullscritem,this.color.iconhovercolor,this.id);
    this.rightitem.appendChild(this.fullscritem);
    this.closeitem = this.main.window.document.createElement("div");
    this.closeitem.style.width = "auto";
    this.closeitem.style.height = this.height + "px";
    this.closeitem.style.overflow = "hidden";
    this.closeitem.draggable = false;
    this.main.colorClass.setColorClass(this.closeitem,this.color.iconbgcolor,this.id);
    this.main.colorClass.setColorClass(this.closeitem,this.color.iconcolor,this.id);
    this.main.colorClass.setClass(this.closeitem,this.color.iconhoverbgcolor,this.id);
    this.main.colorClass.setClass(this.closeitem,this.color.iconhovercolor,this.id);
    this.closeitem.innerHTML = this.closeIcon;
    this.rightitem.appendChild(this.closeitem);
    if (this.parentObj) {
      this.parentObj.appendChild(this.titlebar);
    }
    this.dblclickTimer = null;
    const current = this;
    for(let itemName of ["min","normalscr","fullscr","close"]) {
      let item = this[itemName + "item"];
      item.addEventListener("mouseover", () => {
        this.main.colorClass.setColorClass(item,current.color.iconhoverbgcolor,current.id);
        this.main.colorClass.setColorClass(item,current.color.iconhovercolor,current.id);
        this.onmouseover[itemName](itemName);
      });
      item.addEventListener("mouseout", () => {
        this.main.colorClass.setColorClass(item,current.color.iconbgcolor,current.id);
        this.main.colorClass.setColorClass(item,current.color.iconcolor,current.id);
        this.onmouseout[itemName](itemName);
      });
      item.addEventListener("click", () => {
        this.onclick[itemName](itemName);
      });
      item.addEventListener("pointermove", (e) => {
        this.onpointermove[itemName](itemName,e);
      });
    }
    for(let itemName of ["titlebar","menu"]) {
      let item = this[itemName + "item"];
      if (itemName === "titlebar") {
        item = this.titlebar;
      }
      item.addEventListener("mouseover", () => {
        this.onmouseover[itemName](itemName);
      });
      item.addEventListener("mouseout", () => {
        this.onmouseout[itemName](itemName);
      });
      item.addEventListener("click", (e) => {
        e.preventDefault();
        if (this.dblclickTimer !== null){
          clearTimeout(this.dblclickTimer);
          this.dblclickTimer = null;
          this.ondblclick[itemName](itemName);
          return;          
        }
        this.dblclickTimer = setTimeout(() => {
          this.dblclickTimer = null;
          this.onclick[itemName](itemName);
        },300);
      });
      item.addEventListener("pointermove", (e) => {
        this.onpointermove[itemName](itemName,e);
      });
      item.addEventListener("touchstart", (e) => {
        this.ontouchstart[itemName](itemName,e);
      });
      item.addEventListener("touchend", (e) => {
        this.ontouchend[itemName](itemName,e);
      });
      item.addEventListener("touchmove", (e) => {
        this.ontouchmove[itemName](itemName,e);
      });
    }
    this.update();
  }
  setTop(){
    this.main.colorClass.setColorClass(this.titleitem,this.color.topbgcolor,this.id);
    this.main.colorClass.setColorClass(this.titleitem,this.color.topcolor,this.id);
    this.main.colorClass.setColorClass(this.titlebar,this.color.topbgcolor,this.id);
    this.main.colorClass.setColorClass(this.titlebar,this.color.topcolor,this.id);
  }
  unsetTop(){
    this.main.colorClass.setColorClass(this.titleitem,this.color.bgcolor,this.id);
    this.main.colorClass.setColorClass(this.titleitem,this.color.color,this.id);
    this.main.colorClass.setColorClass(this.titlebar,this.color.bgcolor,this.id);
    this.main.colorClass.setColorClass(this.titlebar,this.color.color,this.id);
  }
  update() {
    if (!this.visible) {
      this.titlebar.style.display = "none";
    } else {
      this.titlebar.style.display = "flex";
    }
    if (!this.showMenuIcon) {
      this.menuitem.style.display = "none";
    }else{
      this.menuitem.style.display = "block";
    }
    this.titleitem.innerHTML = this.title;
    if (!this.showTitle) {
      this.titleitem.style.display = "none";
    }else{
      this.titleitem.style.display = "block";
    }
    if (!this.showMinIcon) {
      this.minitem.style.display = "none";
    } else {
      this.minitem.style.display = "block";
    }
    if (!this.showFullscrIcon) {
      this.normalscritem.style.display = "block";
      this.fullscritem.style.display = "none";
    }else{
      this.normalscritem.style.display = "none";
      this.fullscritem.style.display = "block";
    }
    if (!this.showCloseIcon) {
      this.closeitem.style.display = "none";
    }else{
      this.closeitem.style.display = "block";
    }
  }
}

// ================================================
// module: browser , from: window.js
// ================================================
const Window = self.Window = class Window {
  static WindowMode = {
    Normal: 0,
    FullScreen: 1,
    Minimized: 2,
  };
  static currentWindowId = 0;
  constructor(main,parentObj,options) {
    Window.currentWindowId++;
    this.id = Window.currentWindowId;
    if (!options) {
      options = {};
    }
    this.main = main;
    this.options = options;
    this.visible = true;
    this.parentObj = parentObj || null;
    this.mode = options.mode || Window.WindowMode.Normal;
    this.childSmallWindow = [];
    this.childWindow = [];
    this.window = this.main.window.document.createElement("div");
    if (options.fixsize) {
      this.window.style.resize = "none";
    }else{
      this.window.style.resize = "both";
    }
    this.window.style.overflow = "hidden";
    this.window.style.width = options.width || "200px";
    this.window.style.height = options.height || "100px";
    this.window.style.top = options.top || "0px";
    this.window.style.left = options.left || "0px";
    this.window.style.borderWidth = "1px";
    this.main.colorClass.setColor(this.window,"WindowBorderColor",this.id);
    this.window.style.borderStyle = "solid";
    if (parentObj) {
      this.window.style.position = "absolute";
      this.window.boxSize = "border-box";
      if (parentObj instanceof Window) {
        this.parentObj.body.appendChild(this.window);
        this.parentObj.addChildWindow(this);
      }else{
        this.parentObj.appendChild(this.window);
      }
    }else{
      this.window.style.position = "fixed";
      this.main.window.document.body.appendChild(this.window);
    }
    this.titlebar = this.main.window.document.createElement("div");
    this.tooltip = this.main.window.document.createElement("div");
    this.tooltip.style.position = "fixed";
    this.tooltip.style.display = "none";
    this.main.colorClass.setColorClass(this.tooltip,"WindowTooltipBackgroundColor",this.id);
    this.main.colorClass.setColorClass(this.tooltip,"WindowTooltipColor",this.id);
    this.tooltip.style.padding = "4px";
    this.tooltip.style.borderRadius = "4px";
    this.tooltip.style.zIndex = "1000";
    this.tooltip.style.boxShadow = "0px 0px 4px " + this.main.colorClass.getColor("WindowTooltipBackgroundColor");
    this.tooltip.style.transition = "opacity 0.2s";
    this.window.appendChild(this.tooltip);
    this.window.appendChild(this.titlebar);
    this.original = {
      width: this.window.style.width,
      height: this.window.style.height,
      top: this.window.style.top,
      left: this.window.style.left,
      lastMode: Window.WindowMode.Normal,
    };
    const current = this;
    this.changeMode = function(mode) {
      if (current.original.lastMode === Window.WindowMode.Minimized) {
        if (current.parentObj instanceof Window) {
          current.parentObj.childSmallWindow = current.parentObj.childSmallWindow.map((e,i) => {
            if (e === current) {
              return null;
            }
            return e;
          });
          while(current.parentObj.childSmallWindow[current.parentObj.childSmallWindow.length - 1] === null){
            current.parentObj.childSmallWindow.pop();
          }
        }
        switch (mode) {
          case Window.WindowMode.Normal:
            current.titlebarObj.showMinIcon = true;
            current.titlebarObj.showFullscrIcon = true;
            current.titlebarObj.showTitle = true;
            current.window.style.top = current.original.top;
            current.window.style.left = current.original.left;
            current.window.style.width = current.original.width;
            current.window.style.height = current.original.height;
            current.original.lastMode = Window.WindowMode.Normal;
            break;
          case Window.WindowMode.FullScreen:
            current.titlebarObj.showMinIcon = true;
            current.titlebarObj.showFullscrIcon = false;
            current.titlebarObj.showTitle = true;
            current.window.style.top = "0px";
            current.window.style.left = "0px";
            current.window.style.width = "calc(100%-2px)";
            current.window.style.height = "calc(100%-2px)";
            current.original.lastMode = Window.WindowMode.FullScreen;
            break;
        }
        current.titlebarObj.update();
        return;
      }
      switch (mode) {
        case Window.WindowMode.Normal:
          current.titlebarObj.showMinIcon = true;
          current.titlebarObj.showFullscrIcon = true;
          current.titlebarObj.showTitle = true;
          current.window.style.top = current.original.top;
          current.window.style.left = current.original.left;
          current.window.style.width = current.original.width;
          current.window.style.height = current.original.height;
          current.original.lastMode = Window.WindowMode.Normal;
          break;
        case Window.WindowMode.FullScreen:
          current.original.lastMode = Window.WindowMode.FullScreen,
          current.window.style.top = "0px";
          current.window.style.left = "0px";
          current.window.style.width = "calc(100% - 2px)";
          current.window.style.height = "calc(100% - 2px)";
          current.titlebarObj.showMinIcon = true;
          current.titlebarObj.showFullscrIcon = false;
          current.titlebarObj.showTitle = true;
          break;
        case Window.WindowMode.Minimized:
          if (current.original.lastMode === Window.WindowMode.Normal) {
            current.window.style.top = current.original.top;
            current.window.style.left = current.original.left;
            current.window.style.width = current.original.width;
            current.window.style.height = current.original.height;
            current.titlebarObj.showFullscrIcon = false;
          }else if (current.original.lastMode === Window.WindowMode.FullScreen) {
            current.titlebarObj.showFullscrIcon = true;
          }
          current.original.lastMode = Window.WindowMode.Minimized;
          current.window.style.top = "calc(100% - 20px)";
          if (current.parentObj instanceof Window) {
            let idx = current.parentObj.childSmallWindow.indexOf(null);
            if (idx < 0) {
              idx = current.parentObj.childSmallWindow.length;
              current.parentObj.childSmallWindow.push(current);
            }
            current.window.style.left = (idx * 60) + "px";
            current.parentObj.childSmallWindow[idx] = current;
          }else{
            current.window.style.left = "0px";
          }
          current.window.style.width = "60px";
          current.window.style.height = "20px";  
          current.titlebarObj.showMinIcon = false;
          current.titlebarObj.showTitle = false;
          break;
      }
      current.titlebarObj.update();
    };
    this.titlebarObj = new TitleBar(this.main,this.titlebar,{
      title: options.title || "Window",
      onclick: {
        close: function() {
          console.log("Close");
        },
        normalscr: function() {
          current.changeMode(Window.WindowMode.Normal);
        },
        fullscr: function() {
          current.changeMode(Window.WindowMode.FullScreen);
        },
        min: function() {
          current.changeMode(Window.WindowMode.Minimized);
        },
        menu: function() {
          console.log("Menu");
        },
        titlebar: function() {
          current.setTop();
        },
      },
      ondblclick: {
        titlebar: function() {
          if (current.original.lastMode === Window.WindowMode.Normal) {
            current.changeMode(Window.WindowMode.FullScreen);
          }else if (current.original.lastMode === Window.WindowMode.FullScreen) {
            current.changeMode(Window.WindowMode.Normal);
          }else if (current.original.lastMode === Window.WindowMode.Minimized) {
            if (current.titlebarObj.showFullscrIcon) {
              current.changeMode(Window.WindowMode.FullScreen);
            }else{
              current.changeMode(Window.WindowMode.Normal);
            }
          }
        },
      },
      onmouseover: {
        menu: function() {
          current.tooltip.style.display = "block";
          current.tooltip.innerHTML = current.titlebarObj.title;
          current.tooltip.style.left = current.titlebarObj.menuitem.getBoundingClientRect().left + "px";
          if (current.parentObj instanceof Window) {
            if (current.titlebarObj.menuitem.getBoundingClientRect().bottom > current.parentObj.body.getBoundingClientRect().bottom/2) {
              current.tooltip.style.top = current.titlebarObj.menuitem.getBoundingClientRect().top - current.tooltip.getBoundingClientRect().height + "px";
            }else{
              current.tooltip.style.top = current.titlebarObj.menuitem.getBoundingClientRect().bottom + "px";
            }
          }else{
            current.tooltip.style.top = current.titlebarObj.menuitem.getBoundingClientRect().bottom + "px";
          }
        },
      },
      onmouseout: {
        menu: function() {
          current.tooltip.style.display = "none";
        },
      },
      onpointermove: {
        titlebar: function(target,e) {
          if(e.buttons && (e.pointerType !== "touch" && e.pointerType !== "pen")) {
            if (current.original.lastMode === Window.WindowMode.FullScreen) return;
            current.tooltip.style.display = "none";
            if (e.screenX === 0 && e.screenY === 0) {
              return;
            }
            current.window.style.left     = current.window.offsetLeft + e.movementX + 'px';
            current.window.style.top      = current.window.offsetTop  + e.movementY + 'px';
            //current.window.style.position = 'absolute';
            current.original.top = current.window.style.top;
            current.original.left = current.window.style.left;
            current.titlebarObj.titlebar.setPointerCapture(e.pointerId);
          }
        },
      },
      ontouchstart: {
        titlebar: function(target,e) {
          if (current.original.lastMode === Window.WindowMode.FullScreen) return;
          current.tooltip.style.display = "none";
          e.preventDefault();
          current.touchStartX = e.changedTouches[0].pageX - current.window.offsetLeft;
          current.touchStartY = e.changedTouches[0].pageY - current.window.offsetLeft;
        },
      },
      ontouchend: {
        titlebar: function(target,e) {
          if (current.original.lastMode === Window.WindowMode.FullScreen) return;
          e.preventDefault();
        },
      },
      ontouchmove: {
        titlebar: function(target,e) {
          if (current.original.lastMode === Window.WindowMode.FullScreen) return;
          e.preventDefault();
          if (!/^touch/.test(e.type)) return;
          current.window.style.left = e.changedTouches[0].pageX - current.touchStartX + 'px';
          current.window.style.top = e.changedTouches[0].clientY - current.touchStartY + 'px';
        },
      },
    });
    this.bodybarria = this.main.window.document.createElement("div");
    this.bodybarria.addEventListener("click",function(e){
      current.setTop();
    });
    this.body = this.main.window.document.createElement("div");
    if (options.enableVScrollbar) {
      if (options.enableHScrollbar) {
        this.body.style.overflow = "scroll";
      }else if (options.enableHScrollbar === null) {
        this.body.style.overflow = "auto";
        this.body.style.overflowX = "auto";
        this.body.style.overflowY = "scroll";
      }else{
        this.body.style.overflow = "auto";
        this.body.style.overflowX = "hidden";
        this.body.style.overflowY = "scroll";
      }
    }else if (options.enableVScrollbar === null) {
      if (options.enableHScrollbar) {
        this.body.style.overflow = "auto";
        this.body.style.overflowX = "scroll";
        this.body.style.overflowY = "auto";
      }else if (options.enableHScrollbar === null) {
        this.body.style.overflow = "auto";
        this.body.style.overflowX = "auto";
        this.body.style.overflowY = "auto";
      }else{
        this.body.style.overflow = "auto";
        this.body.style.overflowX = "hidden";
        this.body.style.overflowY = "auto";
      }
    }else{
      if (options.enableHScrollbar) {
        this.body.style.overflow = "auto";
        this.body.style.overflowX = "scroll";
        this.body.style.overflowY = "hiedden";
      }else if (options.enableHScrollbar === null) {
        this.body.style.overflow = "auto";
        this.body.style.overflowX = "auto";
        this.body.style.overflowY = "hidden";
      }else{
        this.body.style.overflow = "hidden";
      }
    }
    this.window.appendChild(this.bodybarria);
    this.bodybarria.appendChild(this.body);
    this.bodybarria.style.position = "absolute";
    this.bodybarria.top = "0px";
    this.bodybarria.left = "0px";
    this.bodybarria.style.width = "100%";
    this.bodybarria.style.height = "calc(100% - " + (this.titlebarObj.titlebar.style.height).replace(/px$/,"") + "px)";
    this.bodybarria.style.overflow = "hidden";
    this.body.style.width = "100%";
    this.body.style.height = "100%";
    this.body.style.top = "0px";
    this.body.style.left = "0px";
    //this.body.style.overflow = "hidden";
    this.main.colorClass.setColorClass(this.body,"WindowBackgroundColor",this.id);
  }
  addChildWindow(window) {
    this.childWindow.push({window:window,zIndex:this.childWindow.length});
  }
  removeChildWindow(window) {
    this.childWindow = this.childWindow.filter(e => e.window !== window);
  }
  setTop(){
    if (this.parentObj instanceof Window) {
      this.parentObj.childWindow = this.parentObj.childWindow.filter(e => e.window !== this).sort((a,b) => a.zIndex - b.zIndex);
      this.parentObj.childWindow.push({window:this,zIndex:this.childWindow.length});
      for(let i=0;i<this.parentObj.childWindow.length;i++){
        this.parentObj.childWindow[i].window.window.style.zIndex = i;
        this.parentObj.childWindow[i].window.titlebarObj.unsetTop();
        this.parentObj.childWindow[i].zIndex = i;      
      }
      this.parentObj.childWindow[this.parentObj.childWindow.length-1].window.titlebarObj.setTop();
    }
  }
}

// ================================================
// module: browser , from: Storage.js
// ================================================
// storage class
const Storage = self.Storage = class Storage {
  constructor(main,g_window) {
    this.main = main;
    this.g_window = g_window;
  }
  #realKeyPrefixName(){
    return APP_ID + "_" + this.main.tieName + "_";
  }
  #realKeyName(key) {
    return this.#realKeyPrefixName() + key;
  }
  save(key, value) {
    this.g_window.localStorage.setItem(this.#realKeyName(key),JSON.stringify(value));
  }
  load(key, defaultValue) {
    if (defaultValue === undefined) defaultValue = null;
    const v = this.g_window.localStorage.getItem(this.#realKeyName(key));
    if (v === null) return defaultValue;
    try{
      return JSON.parse(v);
    }catch(e){
      console.log(e);
      return defaultValue;
    }
  }
  delete(key) {
    this.g_window.localStorage.removeItem(this.#realKeyName(key));  
  }
  keys(prefix) {
    const r = [];
    const gprefx = this.#realKeyPrefixName();
    if (prefix === undefined || prefix === null) prefix = '';
    for (let i = 0; i < this.g_window.localStorage.length; i++) {
      const name = this.g_window.localStorage.key(i);
      if (name !== '') {
        if (name.startsWith(gprefx)) {
          const n = name.substring(gprefx.length);
          if (n.startsWith(prefix)){
            r.push(n.substring(prefix.length));
          }
        }
      } 
    }
    return r;
  }
  clear(prefix) {
    if (prefix === undefined || prefix == null) prefix = '';
    for(let k of this.keys(prefix)) {
      this.delete(k);
    }
  }
  clearAllStorageData(){
    this.g_window.localStorage.clear();
  }
}

app.modules.browser.vendor = {};

const vendor = self.vendor = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser.vendor";
app.modules.browser.vendor.blurhash = {};

const blurhash = self.blurhash = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser.vendor.blurhash";
// ================================================
// module: browser.vendor.blurhash , from: base83.js
// ================================================
const digitCharacters = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "#",
  "$",
  "%",
  "*",
  "+",
  ",",
  "-",
  ".",
  ":",
  ";",
  "=",
  "?",
  "@",
  "[",
  "]",
  "^",
  "_",
  "{",
  "|",
  "}",
  "~",
];

const decode83 = (str) => {
  let value = 0;
  for (let i = 0; i < str.length; i++) {
    const c = str[i];
    const digit = digitCharacters.indexOf(c);
    value = value * 83 + digit;
  }
  return value;
};

const encode83 = (n, length) => {
  var result = "";
  for (let i = 1; i <= length; i++) {
    let digit = (Math.floor(n) / Math.pow(83, length - i)) % 83;
    result += digitCharacters[Math.floor(digit)];
  }
  return result;
};

// ================================================
// module: browser.vendor.blurhash , from: decode.js
// ================================================
/**
 * Returns an error message if invalid or undefined if valid
 * @param blurhash
 */
const validateBlurhash = (blurhash) => {
  if (!blurhash || blurhash.length < 6) {
    throw new ValidationError(
      "The blurhash string must be at least 6 characters"
    );
  }

  const sizeFlag = decode83(blurhash[0]);
  const numY = Math.floor(sizeFlag / 9) + 1;
  const numX = (sizeFlag % 9) + 1;

  if (blurhash.length !== 4 + 2 * numX * numY) {
    throw new ValidationError(
      `blurhash length mismatch: length is ${
        blurhash.length
      } but it should be ${4 + 2 * numX * numY}`
    );
  }
};

const isBlurhashValid = (
  blurhash
) => {
  try {
    validateBlurhash(blurhash);
  } catch (error) {
    return { result: false, errorReason: error.message };
  }

  return { result: true };
};

const decodeDC = (value) => {
  const intR = value >> 16;
  const intG = (value >> 8) & 255;
  const intB = value & 255;
  return [sRGBToLinear(intR), sRGBToLinear(intG), sRGBToLinear(intB)];
};

const decodeAC = (value, maximumValue) => {
  const quantR = Math.floor(value / (19 * 19));
  const quantG = Math.floor(value / 19) % 19;
  const quantB = value % 19;

  const rgb = [
    signPow((quantR - 9) / 9, 2.0) * maximumValue,
    signPow((quantG - 9) / 9, 2.0) * maximumValue,
    signPow((quantB - 9) / 9, 2.0) * maximumValue,
  ];

  return rgb;
};

const decode = self.decode = (
  blurhash,
  width,
  height,
  punch
) => {
  validateBlurhash(blurhash);

  punch = punch | 1;

  const sizeFlag = decode83(blurhash[0]);
  const numY = Math.floor(sizeFlag / 9) + 1;
  const numX = (sizeFlag % 9) + 1;

  const quantisedMaximumValue = decode83(blurhash[1]);
  const maximumValue = (quantisedMaximumValue + 1) / 166;

  const colors = new Array(numX * numY);

  for (let i = 0; i < colors.length; i++) {
    if (i === 0) {
      const value = decode83(blurhash.substring(2, 6));
      colors[i] = decodeDC(value);
    } else {
      const value = decode83(blurhash.substring(4 + i * 2, 6 + i * 2));
      colors[i] = decodeAC(value, maximumValue * punch);
    }
  }

  const bytesPerRow = width * 4;
  const pixels = new Uint8ClampedArray(bytesPerRow * height);

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let r = 0;
      let g = 0;
      let b = 0;

      for (let j = 0; j < numY; j++) {
        const basisY = Math.cos((Math.PI * y * j) / height);
        for (let i = 0; i < numX; i++) {
          const basis = Math.cos((Math.PI * x * i) / width) * basisY;
          const color = colors[i + j * numX];
          r += color[0] * basis;
          g += color[1] * basis;
          b += color[2] * basis;
        }
      }

      let intR = linearTosRGB(r);
      let intG = linearTosRGB(g);
      let intB = linearTosRGB(b);

      pixels[4 * x + 0 + y * bytesPerRow] = intR;
      pixels[4 * x + 1 + y * bytesPerRow] = intG;
      pixels[4 * x + 2 + y * bytesPerRow] = intB;
      pixels[4 * x + 3 + y * bytesPerRow] = 255; // alpha
    }
  }
  return pixels;
};

// ================================================
// module: browser.vendor.blurhash , from: encode.js
// ================================================
const bytesPerPixel = 4;

const multiplyBasisFunction = (
  pixels,
  width,
  height,
  basisFunction
) => {
  let r = 0;
  let g = 0;
  let b = 0;
  const bytesPerRow = width * bytesPerPixel;

  for (let x = 0; x < width; x++) {
    const bytesPerPixelX = bytesPerPixel * x;

    for (let y = 0; y < height; y++) {
      const basePixelIndex = bytesPerPixelX + y * bytesPerRow;
      const basis = basisFunction(x, y);
      r +=
        basis * sRGBToLinear(pixels[basePixelIndex]);
      g +=
        basis * sRGBToLinear(pixels[basePixelIndex + 1]);
      b +=
        basis * sRGBToLinear(pixels[basePixelIndex + 2]);
    }
  }

  let scale = 1 / (width * height);

  return [r * scale, g * scale, b * scale];
};

const encodeDC = (value) => {
  const roundedR = linearTosRGB(value[0]);
  const roundedG = linearTosRGB(value[1]);
  const roundedB = linearTosRGB(value[2]);
  return (roundedR << 16) + (roundedG << 8) + roundedB;
};

const encodeAC = (value, maximumValue) => {
  let quantR = Math.floor(
    Math.max(
      0,
      Math.min(18, Math.floor(signPow(value[0] / maximumValue, 0.5) * 9 + 9.5))
    )
  );
  let quantG = Math.floor(
    Math.max(
      0,
      Math.min(18, Math.floor(signPow(value[1] / maximumValue, 0.5) * 9 + 9.5))
    )
  );
  let quantB = Math.floor(
    Math.max(
      0,
      Math.min(18, Math.floor(signPow(value[2] / maximumValue, 0.5) * 9 + 9.5))
    )
  );

  return quantR * 19 * 19 + quantG * 19 + quantB;
};

const encode = self.encode = (
  pixels,
  width,
  height,
  componentX,
  componentY
) => {
  if (componentX < 1 || componentX > 9 || componentY < 1 || componentY > 9) {
    throw new ValidationError("BlurHash must have between 1 and 9 components");
  }
  if (width * height * 4 !== pixels.length) {
    throw new ValidationError("Width and height must match the pixels array");
  }

  let factors = [];
  for (let y = 0; y < componentY; y++) {
    for (let x = 0; x < componentX; x++) {
      const normalisation = x == 0 && y == 0 ? 1 : 2;
      const factor = multiplyBasisFunction(
        pixels,
        width,
        height,
        (i, j) =>
          normalisation *
          Math.cos((Math.PI * x * i) / width) *
          Math.cos((Math.PI * y * j) / height)
      );
      factors.push(factor);
    }
  }

  const dc = factors[0];
  const ac = factors.slice(1);

  let hash = "";

  let sizeFlag = componentX - 1 + (componentY - 1) * 9;
  hash += encode83(sizeFlag, 1);

  let maximumValue;
  if (ac.length > 0) {
    let actualMaximumValue = Math.max(...ac.map((val) => Math.max(...val)));
    let quantisedMaximumValue = Math.floor(
      Math.max(0, Math.min(82, Math.floor(actualMaximumValue * 166 - 0.5)))
    );
    maximumValue = (quantisedMaximumValue + 1) / 166;
    hash += encode83(quantisedMaximumValue, 1);
  } else {
    maximumValue = 1;
    hash += encode83(0, 1);
  }

  hash += encode83(encodeDC(dc), 4);

  ac.forEach((factor) => {
    hash += encode83(encodeAC(factor, maximumValue), 2);
  });

  return hash;
};

// ================================================
// module: browser.vendor.blurhash , from: error.js
// ================================================
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
    this.message = message;
  }
}

// ================================================
// module: browser.vendor.blurhash , from: util.js
// ================================================
const sRGBToLinear = (value) => {
  let v = value / 255;
  if (v <= 0.04045) {
    return v / 12.92;
  } else {
    return Math.pow((v + 0.055) / 1.055, 2.4);
  }
};

const linearTosRGB = (value) => {
  let v = Math.max(0, Math.min(1, value));
  if (v <= 0.0031308) {
    return Math.trunc(v * 12.92 * 255 + 0.5);
  } else {
    return Math.trunc((1.055 * Math.pow(v, 1 / 2.4) - 0.055) * 255 + 0.5);
  }
};

const sign = (n) => (n < 0 ? -1 : 1);

const signPow = (val, exp) =>
  sign(val) * Math.pow(Math.abs(val), exp);


Object.assign(app.modules.browser.vendor.blurhash,self);

return self;
}).call({},self);
app.modules.browser.vendor.ThumbHash = {};

const ThumbHash = self.ThumbHash = (function(){
  const self = this.self = this;
  const parent = self.parent = arguments[0] || null;;
  const __MODULE_THIS__ = self.__MODULE_THIS__ = self;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser.vendor.ThumbHash";
// ================================================
// module: browser.vendor.ThumbHash , from: thumbhash.js
// ================================================
/**
 * Encodes an RGBA image to a ThumbHash. RGB should not be premultiplied by A.
 *
 * @param w The width of the input image. Must be ≤100px.
 * @param h The height of the input image. Must be ≤100px.
 * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.
 * @returns The ThumbHash as a Uint8Array.
 */
const rgbaToThumbHash = self.rgbaToThumbHash = function rgbaToThumbHash(w, h, rgba) {
  // Encoding an image larger than 100x100 is slow with no benefit
  if (w > 100 || h > 100) throw new Error(`${w}x${h} doesn't fit in 100x100`)
  let { PI, round, max, cos, abs } = Math

  // Determine the average color
  let avg_r = 0, avg_g = 0, avg_b = 0, avg_a = 0
  for (let i = 0, j = 0; i < w * h; i++, j += 4) {
    let alpha = rgba[j + 3] / 255
    avg_r += alpha / 255 * rgba[j]
    avg_g += alpha / 255 * rgba[j + 1]
    avg_b += alpha / 255 * rgba[j + 2]
    avg_a += alpha
  }
  if (avg_a) {
    avg_r /= avg_a
    avg_g /= avg_a
    avg_b /= avg_a
  }

  let hasAlpha = avg_a < w * h
  let l_limit = hasAlpha ? 5 : 7 // Use fewer luminance bits if there's alpha
  let lx = max(1, round(l_limit * w / max(w, h)))
  let ly = max(1, round(l_limit * h / max(w, h)))
  let l = [] // luminance
  let p = [] // yellow - blue
  let q = [] // red - green
  let a = [] // alpha

  // Convert the image from RGBA to LPQA (composite atop the average color)
  for (let i = 0, j = 0; i < w * h; i++, j += 4) {
    let alpha = rgba[j + 3] / 255
    let r = avg_r * (1 - alpha) + alpha / 255 * rgba[j]
    let g = avg_g * (1 - alpha) + alpha / 255 * rgba[j + 1]
    let b = avg_b * (1 - alpha) + alpha / 255 * rgba[j + 2]
    l[i] = (r + g + b) / 3
    p[i] = (r + g) / 2 - b
    q[i] = r - g
    a[i] = alpha
  }

  // Encode using the DCT into DC (constant) and normalized AC (varying) terms
  let encodeChannel = (channel, nx, ny) => {
    let dc = 0, ac = [], scale = 0, fx = []
    for (let cy = 0; cy < ny; cy++) {
      for (let cx = 0; cx * ny < nx * (ny - cy); cx++) {
        let f = 0
        for (let x = 0; x < w; x++)
          fx[x] = cos(PI / w * cx * (x + 0.5))
        for (let y = 0; y < h; y++)
          for (let x = 0, fy = cos(PI / h * cy * (y + 0.5)); x < w; x++)
            f += channel[x + y * w] * fx[x] * fy
        f /= w * h
        if (cx || cy) {
          ac.push(f)
          scale = max(scale, abs(f))
        } else {
          dc = f
        }
      }
    }
    if (scale)
      for (let i = 0; i < ac.length; i++)
        ac[i] = 0.5 + 0.5 / scale * ac[i]
    return [dc, ac, scale]
  }
  let [l_dc, l_ac, l_scale] = encodeChannel(l, max(3, lx), max(3, ly))
  let [p_dc, p_ac, p_scale] = encodeChannel(p, 3, 3)
  let [q_dc, q_ac, q_scale] = encodeChannel(q, 3, 3)
  let [a_dc, a_ac, a_scale] = hasAlpha ? encodeChannel(a, 5, 5) : []

  // Write the constants
  let isLandscape = w > h
  let header24 = round(63 * l_dc) | (round(31.5 + 31.5 * p_dc) << 6) | (round(31.5 + 31.5 * q_dc) << 12) | (round(31 * l_scale) << 18) | (hasAlpha << 23)
  let header16 = (isLandscape ? ly : lx) | (round(63 * p_scale) << 3) | (round(63 * q_scale) << 9) | (isLandscape << 15)
  let hash = [header24 & 255, (header24 >> 8) & 255, header24 >> 16, header16 & 255, header16 >> 8]
  let ac_start = hasAlpha ? 6 : 5
  let ac_index = 0
  if (hasAlpha) hash.push(round(15 * a_dc) | (round(15 * a_scale) << 4))

  // Write the varying factors
  for (let ac of hasAlpha ? [l_ac, p_ac, q_ac, a_ac] : [l_ac, p_ac, q_ac])
    for (let f of ac)
      hash[ac_start + (ac_index >> 1)] |= round(15 * f) << ((ac_index++ & 1) << 2)
  return new Uint8Array(hash)
}

/**
 * Decodes a ThumbHash to an RGBA image. RGB is not be premultiplied by A.
 *
 * @param hash The bytes of the ThumbHash.
 * @returns The width, height, and pixels of the rendered placeholder image.
 */
const thumbHashToRGBA = self.thumbHashToRGBA = function thumbHashToRGBA(hash) {
  let { PI, min, max, cos, round } = Math

  // Read the constants
  let header24 = hash[0] | (hash[1] << 8) | (hash[2] << 16)
  let header16 = hash[3] | (hash[4] << 8)
  let l_dc = (header24 & 63) / 63
  let p_dc = ((header24 >> 6) & 63) / 31.5 - 1
  let q_dc = ((header24 >> 12) & 63) / 31.5 - 1
  let l_scale = ((header24 >> 18) & 31) / 31
  let hasAlpha = header24 >> 23
  let p_scale = ((header16 >> 3) & 63) / 63
  let q_scale = ((header16 >> 9) & 63) / 63
  let isLandscape = header16 >> 15
  let lx = max(3, isLandscape ? hasAlpha ? 5 : 7 : header16 & 7)
  let ly = max(3, isLandscape ? header16 & 7 : hasAlpha ? 5 : 7)
  let a_dc = hasAlpha ? (hash[5] & 15) / 15 : 1
  let a_scale = (hash[5] >> 4) / 15

  // Read the varying factors (boost saturation by 1.25x to compensate for quantization)
  let ac_start = hasAlpha ? 6 : 5
  let ac_index = 0
  let decodeChannel = (nx, ny, scale) => {
    let ac = []
    for (let cy = 0; cy < ny; cy++)
      for (let cx = cy ? 0 : 1; cx * ny < nx * (ny - cy); cx++)
        ac.push((((hash[ac_start + (ac_index >> 1)] >> ((ac_index++ & 1) << 2)) & 15) / 7.5 - 1) * scale)
    return ac
  }
  let l_ac = decodeChannel(lx, ly, l_scale)
  let p_ac = decodeChannel(3, 3, p_scale * 1.25)
  let q_ac = decodeChannel(3, 3, q_scale * 1.25)
  let a_ac = hasAlpha && decodeChannel(5, 5, a_scale)

  // Decode using the DCT into RGB
  let ratio = thumbHashToApproximateAspectRatio(hash)
  let w = round(ratio > 1 ? 32 : 32 * ratio)
  let h = round(ratio > 1 ? 32 / ratio : 32)
  let rgba = new Uint8Array(w * h * 4), fx = [], fy = []
  for (let y = 0, i = 0; y < h; y++) {
    for (let x = 0; x < w; x++, i += 4) {
      let l = l_dc, p = p_dc, q = q_dc, a = a_dc

      // Precompute the coefficients
      for (let cx = 0, n = max(lx, hasAlpha ? 5 : 3); cx < n; cx++)
        fx[cx] = cos(PI / w * (x + 0.5) * cx)
      for (let cy = 0, n = max(ly, hasAlpha ? 5 : 3); cy < n; cy++)
        fy[cy] = cos(PI / h * (y + 0.5) * cy)

      // Decode L
      for (let cy = 0, j = 0; cy < ly; cy++)
        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx * ly < lx * (ly - cy); cx++, j++)
          l += l_ac[j] * fx[cx] * fy2

      // Decode P and Q
      for (let cy = 0, j = 0; cy < 3; cy++) {
        for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 3 - cy; cx++, j++) {
          let f = fx[cx] * fy2
          p += p_ac[j] * f
          q += q_ac[j] * f
        }
      }

      // Decode A
      if (hasAlpha)
        for (let cy = 0, j = 0; cy < 5; cy++)
          for (let cx = cy ? 0 : 1, fy2 = fy[cy] * 2; cx < 5 - cy; cx++, j++)
            a += a_ac[j] * fx[cx] * fy2

      // Convert to RGB
      let b = l - 2 / 3 * p
      let r = (3 * l - b + q) / 2
      let g = r - q
      rgba[i] = max(0, 255 * min(1, r))
      rgba[i + 1] = max(0, 255 * min(1, g))
      rgba[i + 2] = max(0, 255 * min(1, b))
      rgba[i + 3] = max(0, 255 * min(1, a))
    }
  }
  return { w, h, rgba }
}

/**
 * Extracts the average color from a ThumbHash. RGB is not be premultiplied by A.
 *
 * @param hash The bytes of the ThumbHash.
 * @returns The RGBA values for the average color. Each value ranges from 0 to 1.
 */
function thumbHashToAverageRGBA(hash) {
  let { min, max } = Math
  let header = hash[0] | (hash[1] << 8) | (hash[2] << 16)
  let l = (header & 63) / 63
  let p = ((header >> 6) & 63) / 31.5 - 1
  let q = ((header >> 12) & 63) / 31.5 - 1
  let hasAlpha = header >> 23
  let a = hasAlpha ? (hash[5] & 15) / 15 : 1
  let b = l - 2 / 3 * p
  let r = (3 * l - b + q) / 2
  let g = r - q
  return {
    r: max(0, min(1, r)),
    g: max(0, min(1, g)),
    b: max(0, min(1, b)),
    a
  }
}

/**
 * Extracts the approximate aspect ratio of the original image.
 *
 * @param hash The bytes of the ThumbHash.
 * @returns The approximate aspect ratio (i.e. width / height).
 */
function thumbHashToApproximateAspectRatio(hash) {
  let header = hash[3]
  let hasAlpha = hash[2] & 0x80
  let isLandscape = hash[4] & 0x80
  let lx = isLandscape ? hasAlpha ? 5 : 7 : header & 7
  let ly = isLandscape ? header & 7 : hasAlpha ? 5 : 7
  return lx / ly
}

/**
 * Encodes an RGBA image to a PNG data URL. RGB should not be premultiplied by
 * A. This is optimized for speed and simplicity and does not optimize for size
 * at all. This doesn't do any compression (all values are stored uncompressed).
 *
 * @param w The width of the input image. Must be ≤100px.
 * @param h The height of the input image. Must be ≤100px.
 * @param rgba The pixels in the input image, row-by-row. Must have w*h*4 elements.
 * @returns A data URL containing a PNG for the input image.
 */
const rgbaToDataURL = self.rgbaToDataURL = function rgbaToDataURL(w, h, rgba) {
  let row = w * 4 + 1
  let idat = 6 + h * (5 + row)
  let bytes = [
    137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0,
    w >> 8, w & 255, 0, 0, h >> 8, h & 255, 8, 6, 0, 0, 0, 0, 0, 0, 0,
    idat >>> 24, (idat >> 16) & 255, (idat >> 8) & 255, idat & 255,
    73, 68, 65, 84, 120, 1
  ]
  let table = [
    0, 498536548, 997073096, 651767980, 1994146192, 1802195444, 1303535960,
    1342533948, -306674912, -267414716, -690576408, -882789492, -1687895376,
    -2032938284, -1609899400, -1111625188
  ]
  let a = 1, b = 0
  for (let y = 0, i = 0, end = row - 1; y < h; y++, end += row - 1) {
    bytes.push(y + 1 < h ? 0 : 1, row & 255, row >> 8, ~row & 255, (row >> 8) ^ 255, 0)
    for (b = (b + a) % 65521; i < end; i++) {
      let u = rgba[i] & 255
      bytes.push(u)
      a = (a + u) % 65521
      b = (b + a) % 65521
    }
  }
  bytes.push(
    b >> 8, b & 255, a >> 8, a & 255, 0, 0, 0, 0,
    0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130
  )
  for (let [start, end] of [[12, 29], [37, 41 + idat]]) {
    let c = ~0
    for (let i = start; i < end; i++) {
      c ^= bytes[i]
      c = (c >>> 4) ^ table[c & 15]
      c = (c >>> 4) ^ table[c & 15]
    }
    c = ~c
    bytes[end++] = c >>> 24
    bytes[end++] = (c >> 16) & 255
    bytes[end++] = (c >> 8) & 255
    bytes[end++] = c & 255
  }
  return 'data:image/png;base64,' + btoa(String.fromCharCode(...bytes))
}

/**
 * Decodes a ThumbHash to a PNG data URL. This is a convenience function that
 * just calls "thumbHashToRGBA" followed by "rgbaToDataURL".
 *
 * @param hash The bytes of the ThumbHash.
 * @returns A data URL containing a PNG for the rendered ThumbHash.
 */
const thumbHashToDataURL = self.thumbHashToDataURL = function thumbHashToDataURL(hash) {
  let image = thumbHashToRGBA(hash)
  return rgbaToDataURL(image.w, image.h, image.rgba)
}


Object.assign(app.modules.browser.vendor.ThumbHash,self);

return self;
}).call({},self);

Object.assign(app.modules.browser.vendor,self);

return self;
}).call({},self);

Object.assign(app.modules.browser,self);

return self;
}).call({},self);

// ================================================
// source: Main.js
// ================================================
// Main (export) class
const Main = self.Main = class Main {
  constructor(targetObj, tieName, bodyObj,opt) {
    this.$tie = Main.$tie;
    this.window = app.g_window;
    this.targetObj = targetObj;
    this.targetObj.style.overflow = "hidden";
    if (tieName === undefined || tieName === null) {
      tieName = 'default';
    }
    if (!opt){
      opt = {};
    }
    this.tieName = tieName;
    if (bodyObj === undefined || bodyObj === null){
      bodyObj = app.g_window.document.getElementsByTagName("body")[0];
    }
    this.bodyObj = bodyObj;
    this.option = opt;
    this.colorClass = new modules.browser.ColorClass(this.option.color);
    this.colorClass.setClassBaseName(app.APP_ID);
    this.colorClass.setClassInstanceName(this.tieName);
    this.storage = new modules.browser.Storage(this,this.window);
    this.history = {
      maxdepth: -1,
    };
    this.baseCanvas = this.window.document.createElement("canvas");
    this.baseCanvas.width = this.targetObj.getBoundingClientRect().width;
    this.baseCanvas.height = this.targetObj.getBoundingClientRect().height;
    this.defaultLayer = {
      width: this.baseCanvas.width,
      height: this.baseCanvas.height,
    };

    this.testWindow = new modules.browser.Window(this,this.targetObj,{
      enableVScrollbar: false,
      enableHScrollbar: false,
      fixsize: false,
      title:"Test Window",
      width: 800 + "px",
      height: 600 + "px",
    });
    this.targetObj.appendChild(this.baseCanvas);

    this.testWindow2 = new modules.browser.Window(this,this.testWindow,{
      enableVScrollbar: null,
      enableHScrollbar: null,
      fixsize: false,
      title:"Test Window2",
      width: 640 + "px",
      height: 480 + "px",
    });
    this.testWindow3 = new modules.browser.Window(this,this.testWindow,{
      enableVScrollbar: null,
      enableHScrollbar: null,
      fixsize: false,
      title:"Test Window3",
      width: 640 + "px",
      height: 480 + "px",
      top: 20 + "px",
      left: 20 + "px",
    });
    //this.testWindow.body.appendChild(this.testWindow2);

    this.viewerLayer = new modules.browser.Layer(this,this.defaultLayer.width,this.defaultLayer.height);

    this.clearpatternLayer = new modules.browser.Layer(this,this.defaultLayer.width,this.defaultLayer.height);
    this.clearpatternLayer.insertLastLayer(this.viewerLayer);

    this.baseLayer = new modules.browser.Layer(this,this.defaultLayer.width,this.defaultLayer.height,{writeClip: true});
    this.baseLayer.insertLastLayer(this.clearpatternLayer);
    this.baseLayer.addSyncPositionLayer(this.clearpatternLayer);
    this.baseLayer.addSyncAngleLayer(this.clearpatternLayer);
    this.baseLayer.addSyncScaleLayer(this.clearpatternLayer);

    this.layer = new modules.browser.Layer(this,this.defaultLayer.width,this.defaultLayer.height);
    this.baseLayer.addBelowLayer(this.layer);
    this.layer2 = new modules.browser.Layer(this,this.defaultLayer.width,this.defaultLayer.height);
    this.baseLayer.addBelowLayer(this.layer2);

    modules.browser.canvasMethod.fillClearPattern(this.clearpatternLayer.canvas);
    this.viewerLayer.outputCurrentLayer(this.baseCanvas);
    this.window.addEventListener("DOMContentLoaded", () =>{
      const ovserver = new ResizeObserver(() => {
        this.baseCanvas.width = this.targetObj.getBoundingClientRect().width;
        this.baseCanvas.height = this.targetObj.getBoundingClientRect().height;
        this.viewerLayer.getCanvas().resize(this.baseCanvas.width, this.baseCanvas.height);
        modules.browser.canvasMethod.fillClearPattern(this.clearpatternLayer.canvas);
        this.viewerLayer.outputCurrentLayer(this.baseCanvas);
      });
      ovserver.observe(this.targetObj);
    });
  }
  static $tie = $tie;
}

return Main;
}).call({},{});
