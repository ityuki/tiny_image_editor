const Tie = (function(){
  const app = this.app = this;
  const modules = app.modules = {};
  const g_window = app.g_window = window;
  const APP_ID = app.APP_ID = "tie";
  const $tie = app.$tie = app;

  const self = this;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID;
// ================================================
// source: functions.js
// ================================================
const regExpEscape = self.regExpEscape = function regExpEscape(str) {
  return str.replace(/[-\/\\^$*+?.()|\[\]{}]/g, '\\$&');
};

app.modules.utils = {};

const module_utils = self.module_utils = (function(){
  const self = this.self = this;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".utils";
// ================================================
// module: utils , from: fonts.js
// ================================================
// fonts class
// fonts Sample
/*
console.log(Fonts.getFontNames());
*/
const Fonts = self.Fonts = class Fonts {
  static fontlist = [];
  static init = false;
  static fonthash = {};
  static getFontNames() {
    if (!Fonts.init){
      return null;
    }
    const r = [];
    for (let font of Fonts.fontlist){
      r.push(font.name);
    }
    return r;
  }
  static getFontLangs (name){
    if (!Fonts.init){
      return null;
    }
    return Fonts.fonthash[name].lang;
  }
  static {
    window.addEventListener('fontfamily_list-loaded',function(event){
      const fontfamily_list = event.detail;
      Fonts.fontlist = fontfamily_list;
      for (let font of fontfamily_list){
        Fonts.fonthash[font.name] = {
          lang: font.lang,
        };
      }
      Fonts.init = true;
    });
  };
};



// ================================================
// module: utils , from: MTRand.js
// ================================================
// rand class
// MTRand Sample
/*
console.log((new MTRand([0x123, 0x234, 0x345, 0x456])).randN(5));
console.log("1067595299  955945823  477289528 4107218783 4228976476");
*/
const MTRand = self.MTRand = class MTRand {
  constructor(seed){
    this.N = 624;
    this.M = 397;
    this.MATRIX_A = 0x9908b0df;
    this.UPPER_MASK = 0x80000000;
    this.LOWER_MASK = 0x7fffffff;
    this.mt = new Array(this.N);
    this.mti = this.N + 1;
    if (seed !== undefined){
      if (typeof seed === 'number'){
        this.init(seed);
      }else{
        this.init_by_array(seed);
      }
    }
  }
  xor(a,b){
    return ((((a >>> 16) & 0x0000ffff) ^ ((b >>> 16) & 0x0000ffff)) << 16) + ((a & 0x0000ffff) ^ (b & 0x0000ffff)) >>> 0;
  }
  mul(a,b){
    if (a < b){
      const t = a;
      a = b;
      b = t;
    }
    return ((((a >>> 16) & 0x0000ffff) * b) << 16) + ((a & 0x0000ffff) * b) >>> 0;
  }
  init(seed){
    this.seed = seed;
    this.mt[0] = seed >>> 0; // this.mt[0] = seed & 0xffffffff;
    for (this.mti=1; this.mti<this.N; this.mti++) {
      this.mt[this.mti] = (this.mul(1812433253 , (this.xor(this.mt[this.mti-1] , (this.mt[this.mti-1] >>> 30)))) + this.mti);
      this.mt[this.mti] = this.mt[this.mti] >>> 0; //this.mt[this.mti] &= 0xffffffff;
    }
  }
  init_by_array(seeds){
    this.seed = seeds;
    let i, j, k;
    this.init(19650218);
    i=1; j=0;
    k = (this.N>seeds.length ? this.N : seeds.length);
    for (; k; k--) {
      this.mt[i] = (this.xor(this.mt[i] , (this.mul(this.xor(this.mt[i-1] , (this.mt[i-1] >>> 30)) , 1664525)))) + seeds[j] + j;
      this.mt[i] = this.mt[i] >>> 0; // this.mt[i] &= 0xffffffff;
      i++; j++;
      if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
      if (j>=seeds.length) j=0;
    }
    for (k=this.N-1; k; k--) {
      this.mt[i] = (this.xor(this.mt[i] , (this.mul(this.xor(this.mt[i-1] , (this.mt[i-1] >>> 30)) , 1566083941)))) - i;
      this.mt[i] = this.mt[i] >>> 0; // this.mt[i] &= 0xffffffff;
      i++;
      if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
    }
    this.mt[0] = 0x80000000;        
  }
  rand(){
    let y;
    const mag01 = [0x0, this.MATRIX_A];
    if (this.mti >= this.N) {
      let kk;
      if (this.mti == this.N+1) this.init(5489);
      for (kk=0;kk<this.N-this.M;kk++) {
        y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
        this.mt[kk] = this.xor(this.xor(this.mt[kk+this.M] , (y >>> 1)) , mag01[y & 0x1]);
      }
      for (;kk<this.N-1;kk++) {
        y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
        this.mt[kk] = this.xor(this.xor(this.mt[kk+(this.M-this.N)] , (y >>> 1)) , mag01[y & 0x1]);
      }
      y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
      this.mt[this.N-1] = this.xor(this.xor(this.mt[this.M-1] , (y >>> 1)) , mag01[y & 0x1]);
      this.mti = 0;
    }
    y = this.mt[this.mti++];
    y = this.xor(y,(y >>> 11));
    y = this.xor(y,(y << 7) & 0x9d2c5680);
    y = this.xor(y,(y << 15) & 0xefc60000);
    y = this.xor(y,(y >>> 18));
    return y >>> 0;
  }
  randN(count){
    const r = new Array(count);
    for(let i=0;i<count;i++){
      r[i] = this.rand();
    }
    console.log(this)
    return r;
  }
}
const rand_vals = self.rand_vals = function rand_vals(seed,count){
  if (count === undefined || count === null || count <= 0) count = 1;
  console.log(this)
  return (new MTRand(seed)).randN(count);
}

app.modules.utils.vendor = {};

const vendor = self.vendor = (function(){
  const self = this.self = this;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".utils.vendor";
app.modules.utils.vendor.fonts = {};

const fonts = self.fonts = (function(){
  const self = this.self = this;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".utils.vendor.fonts";
// ================================================
// module: utils.vendor.fonts , from: fontfamily_list.js
// ================================================
/**
fontfamily-list

Copyright (c) 2021,2024 Ituki Kirihara/NI

This software is released under the MIT License.
http://opensource.org/licenses/mit-license.php

(Adobe-Blank)
This Font Software is licensed under the SIL Open Font License,
Version 1.1.

This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL

*/

(function(){
  const check_font = async function(){
    const check_font_list = [
      'arial',
      'arial black',
      'arial narrow',
      'arial unicode ms',
      'Century Gothic',
      'Franklin Gothic Medium',
      'Gulim',
      'Dotum',
      'Haettenschweiler',
      'Impact',
      'Ludica Sans Unicode',
      'Microsoft Sans Serif',
      'MS Sans Serif',
      'MV Boil',
      'New Gulim',
      'Tahoma',
      'Trebuchet',
      'Verdana',
      'Noto Sans SC',
      'PingFang SC',
      'Microsoft YaHei',
      'Noto Sans TC',
      'PingFang TC',
      'Microsoft JhengHei',
      'Noto Sans KR',
      'Nanum Gothic',
      'Malgun Gothic',
  
      'Batang',
      'Book Antiqua',
      'Bookman Old Style',
      'Century',
      'Estrangelo Edessa',
      'Garamond',
      'Georgia',
      'Gungsuh',
      'Latha',
      'Mangal',
      'MS Serif',
      'PMingLiU',
      'Palatino Linotype',
      'Raavi',
      'Roman',
      'Shruti',
      'Sylfaen',
      'Times New Roman',
      'Tunga',
      'Noto Serif SC',
      'Kaiti SC',
      'SimSun',
      'Noto Serif TC',
      'Kaiti TC',
      'PMingLiU',
      'Noto Serif KR',
      'Nanum Myeongjo',
      'Batang',
  
      'BatangChe',
      'Courier',
      'Courier New',
      'DotumChe',
      'GlimChe',
      'GungsuhChe',
      'HG行書体',
      'Lucida Console',
      'MingLiU',
      'ＭＳ ゴシック',
      'ＭＳ 明朝',
      'OCRB',
      'SimHei',
      'SimSun',
      'Small Fonts',
      'Terminal',
      
      'alba',
      'alba matter',
      'alba super',
      'baby kruffy',
      'Chick',
      'Croobie',
      'Fat',
      'Freshbot',
      'Frosty',
      'GlooGun',
      'Jokewood',
      'Modern',
      'Monotype Corsiva',
      'Poornut',
      'Pussycat Snickers',
      'Weltron Urban',
  
      'Comic Sans MS',
      'HGP行書体',
      'HG正楷書体-PRO',
      'Jenkins v2.0',
      'Script',
  
      'MS UI Gothic',
      'ＭＳ Ｐゴシック',
      'ＭＳ ゴシック',
      'ＭＳ Ｐ明朝',
      'ＭＳ 明朝',
      'メイリオ',
      'Meiryo UI',
      '游ゴシック',
      '游明朝',
      'ヒラギノ角ゴ Pro W3',
      'ヒラギノ角ゴ ProN W3',
      'ヒラギノ角ゴ Pro W6',
      'ヒラギノ角ゴ ProN W6',
      'ヒラギノ角ゴ Std W8',
      'ヒラギノ角ゴ StdN W8',
      'ヒラギノ丸ゴ Pro W4',
      'ヒラギノ丸ゴ ProN W4',
      'ヒラギノ明朝 Pro W3',
      'ヒラギノ明朝 ProN W3',
      'ヒラギノ明朝 Pro W6',
      'ヒラギノ明朝 ProN W6',
      '游ゴシック体',
      '游明朝体',
      'Osaka',
      'Osaka－等幅',
      'Droid Sans',
      'Roboto',
  
      'Noto Sans JP',
      'Noto Sans CJK JP',
      'Noto Sans CJK',
    ];

    const check_font_list_f = [
      'sans-serif',
      'serif',
      'system-ui',
      'monospace',
      'cursive',
      'fantasy',
    ];
    const check_code = "a";
    const check_codepoint = {
      ja: 'あ',
      zh: '开',
      ko: '아',
      ru: 'Б',
    };
    //while(check_font_list.length>0) check_font_list.pop()
    /*
    if ('query' in navigator.permissions){
      const status = await navigator.permissions.query({ name: "local-fonts" })
      if (status.state === "granted"){
        if('fonts' in navigator){
          const iterableFontObject = navigator.fonts.query();
          for await (const metadata of iterableFontObject) {
            const fontname = metadata.family;
            if (!check_font_list.includes(fontname)) check_font_list.push(fontname);
          }  
        }
      }     
    }
    */
    const f = "Blank";
  
    const style = document.createElement('style');
    document.head.appendChild(style);
    style.sheet.insertRule('@font-face{font-family:' + f + ';src:url("data:font/opentype;base64,T1RUTwAKAIAAAwAgQ0ZGIDTeCDQAACFkAAAZPERTSUcAAAABAABKqAAAAAhPUy8yAF+xmwAAARAAAABgY21hcCRDbtEAAAdcAAAZ6GhlYWQFl9tDAAAArAAAADZoaGVhB1oD7wAAAOQAAAAkaG10eAPoAHwAADqgAAAQBm1heHAIAVAAAAABCAAAAAZuYW1lIE0HkgAAAXAAAAXrcG9zdP+4ADIAACFEAAAAIAABAAAAAQuFfcPHtV8PPPUAAwPoAAAAANFMRfMAAAAA0UxF8wB8/4gDbANwAAAAAwACAAAAAAAAAAEAAANw/4gAAAPoAHwAfANsAAEAAAAAAAAAAAAAAAAAAAACAABQAAgBAAAAAwPoAZAABQAAAooCWAAAAEsCigJYAAABXgAyANwAAAAAAAAAAAAAAAD3/67/+9///w/gAD8AAAAAQURCTwBAAAD//wNw/4gAAANwAHhgLwH/AAAAAAAAAAAAAAAgAAAAAAARANIAAQAAAAAAAQALAAAAAQAAAAAAAgAHAAsAAQAAAAAAAwAbABIAAQAAAAAABAALAAAAAQAAAAAABQA6AC0AAQAAAAAABgAKAGcAAwABBAkAAACUAHEAAwABBAkAAQAWAQUAAwABBAkAAgAOARsAAwABBAkAAwA2ASkAAwABBAkABAAWAQUAAwABBAkABQB0AV8AAwABBAkABgAUAdMAAwABBAkACAA0AecAAwABBAkACwA0AhsAAwABBAkADQKWAk8AAwABBAkADgA0BOVBZG9iZSBCbGFua1JlZ3VsYXIxLjA0NTtBREJPO0Fkb2JlQmxhbms7QURPQkVWZXJzaW9uIDEuMDQ1O1BTIDEuMDQ1O2hvdGNvbnYgMS4wLjgyO21ha2VvdGYubGliMi41LjYzNDA2QWRvYmVCbGFuawBDAG8AcAB5AHIAaQBnAGgAdAAgAKkAIAAyADAAMQAzACwAIAAyADAAMQA1ACAAQQBkAG8AYgBlACAAUwB5AHMAdABlAG0AcwAgAEkAbgBjAG8AcgBwAG8AcgBhAHQAZQBkACAAKABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwApAC4AQQBkAG8AYgBlACAAQgBsAGEAbgBrAFIAZQBnAHUAbABhAHIAMQAuADAANAA1ADsAQQBEAEIATwA7AEEAZABvAGIAZQBCAGwAYQBuAGsAOwBBAEQATwBCAEUAVgBlAHIAcwBpAG8AbgAgADEALgAwADQANQA7AFAAUwAgADEALgAwADQANQA7AGgAbwB0AGMAbwBuAHYAIAAxAC4AMAAuADgAMgA7AG0AYQBrAGUAbwB0AGYALgBsAGkAYgAyAC4ANQAuADYAMwA0ADAANgBBAGQAbwBiAGUAQgBsAGEAbgBrAEEAZABvAGIAZQAgAFMAeQBzAHQAZQBtAHMAIABJAG4AYwBvAHIAcABvAHIAYQB0AGUAZABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwB0AHkAcABlAC8AVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAgAFQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAaQBzACAAZABpAHMAdAByAGkAYgB1AHQAZQBkACAAbwBuACAAYQBuACAAIgBBAFMAIABJAFMAIgAgAEIAQQBTAEkAUwAsACAAVwBJAFQASABPAFUAVAAgAFcAQQBSAFIAQQBOAFQASQBFAFMAIABPAFIAIABDAE8ATgBEAEkAVABJAE8ATgBTACAATwBGACAAQQBOAFkAIABLAEkATgBEACwAIABlAGkAdABoAGUAcgAgAGUAeABwAHIAZQBzAHMAIABvAHIAIABpAG0AcABsAGkAZQBkAC4AIABTAGUAZQAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUAIABmAG8AcgAgAHQAaABlACAAcwBwAGUAYwBpAGYAaQBjACAAbABhAG4AZwB1AGEAZwBlACwAIABwAGUAcgBtAGkAcwBzAGkAbwBuAHMAIABhAG4AZAAgAGwAaQBtAGkAdABhAHQAaQBvAG4AcwAgAGcAbwB2AGUAcgBuAGkAbgBnACAAeQBvAHUAcgAgAHUAcwBlACAAbwBmACAAdABoAGkA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wwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wEAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRAVIBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwIsAi0CLgIvAjACMQIyAjMCNAI1AjYCNwI4AjkCOgI7AjwCPQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoDGwMcAx0DHgMfAyADIQMiAyMDJAMlAyYDJwMoAykDKgMrAywDLQMuAy8DMAMxAzIDMwM0AzUDNgM3AzgDOQM6AzsDPAM9Az4DPwNAA0EDQgNDA0QDRQNGA0cDSANJA0oDSwNMA00DTgNPA1ADUQNSA1MDVANVA1YDVwNYA1kDWgNbA1wDXQNeA18DYANhA2IDYwNkA2UDZgNnA2gDaQNqA2sDbANtA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgN/A4ADgQOCA4MDhAOFA4YDhwOIA4kDigOLA4wDjQOOA48DkAORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwOgA6EDogOjA6QDpQOmA6cDqAOpA6oDqwOsA60DrgOvA7ADsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+A78DwAPBA8IDwwPEA8UDxgPHA8gDyQPKA8sDzAPNA84DzwPQA9ED0gPTA9QD1QPWA9cD2APZA9oD2wPcA90D3gPfA+AD4QPiA+MD5APlA+YD5wPoA+kD6gPrA+wD7QPuA+8D8APxA/ID8wP0A/UD9gP3A/gD+QP6A/sD/AP9A/4D/wQABAEEAgQDBAQEBQQGBAcECAQJBAoECwQMBA0EDgQPBBAEEQQSBBMEFAQVBBYEFwQYBBkEGgQbBBwEHQQeBB8EIAQhBCIEIwQkBCUEJgQnBCgEKQQqBCsELAQtBC4ELwQwBDEEMgQzBDQENQQ2BDcEOAQ5BDoEOwQ8BD0EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE8EUARRBFIEUwRUBFUEVgRXBFgEWQRaBFsEXARdBF4EXwRgBGEEYgRjBGQEZQRmBGcEaARpBGoEawRsBG0EbgRvBHAEcQRyBHMEdAR1BHYEdwR4BHkEegR7BHwEfQR+BH8EgASBBIIEgwSEBIUEhgSHBIgEiQSKBIsEjASNBI4EjwSQBJEEkgSTBJQElQSWBJcEmASZBJoEmwScBJ0EngSfBKAEoQSiBKMEpASlBKYEpwSoBKkEqgSrBKwErQSuBK8EsASxBLIEswS0BLUEtgS3BLgEuQS6BLsEvAS9BL4EvwTABMEEwgTDBMQExQTGBMcEyATJBMoEywTMBM0EzgTPBNAE0QTSBNME1ATVBNYE1wTYBNkE2gTbBNwE3QTeBN8E4AThBOIE4wTkBOUE5gTnBOgE6QTqBOsE7ATtBO4E7wTwBPEE8gTzBPQE9QT2BPcE+AT5BPoE+wT8BP0E/gT/BQAFAQUCBQMFBAUFBQYFBwUIBQkFCgULBQwFDQUOBQ8FEAURBRIFEwUUBRUFFgUXBRgFGQUaBRsFHAUdBR4FHwUgBSEFIgUjBSQFJQUmBScFKAUpBSoFKwUsBS0FLgUvBTAFMQUyBTMFNAU1BTYFNwU4BTkFOgU7BTwFPQU+BT8FQAVBBUIFQwVEBUUFRgVHBUgFSQVKBUsFTAVNBU4FTwVQBVEFUgVTBVQFVQVWBVcFWAVZBVoFWwVcBV0FXgVfBWAFYQViBWMFZAVlBWYFZwVoBWkFagVrBWwFbQVuBW8FcAVxBXIFcwV0BXUFdgV3BXgFeQV6BXsFfAV9BX4FfwWABYEFggWDBYQFhQWGBYcFiAWJBYoFiwWMBY0FjgWPBZAFkQWSBZMFlAWVBZYFlwWYBZkFmgWbBZwFnQWeBZ8FoAWhBaIFowWkBaUFpgWnBagFqQWqBasFrAWtBa4FrwWwBbEFsgWzBbQFtQW2BbcFuAW5BboFuwW8Bb0FvgW/BcAFwQXCBcMFxAXFBcYFxwXIBckFygXLBcwFzQXOBc8F0AXRBdIF0wXUBdUF1gXXBdgF2QXaBdsF3AXdBd4F3wXgBeEF4gXjBeQF5QXmBecF6AXpBeoF6wXsBe0F7gXvBfAF8QXyBfMF9AX1BfYF9wX4BfkF+gX7BfwF/QX+Bf8GAAYBBgIGAwYEBgUGBgYHBggGCQYKBgsGDAYNBg4GDwYQBhEGEgYTBhQGFQYWBhcGGAYZBhoGGwYcBh0GHgYfBiAGIQYiBiMGJAYlBiYGJwYoBikGKgYrBiwGLQYuBi8GMAYxBjIGMwY0BjUGNgY3BjgGOQY6BjsGPAY9Bj4GPwZABkEGQgZDBkQGRQZGBkcGSAZJBkoGSwZMBk0GTgZPBlAGUQZSBlMGVAZVBlYGVwZYBlkGWgZbBlwGXQZeBl8GYAZhBmIGYwZkBmUGZgZnBmgGaQZqBmsGbAZtBm4GbwZwBnEGcgZzBnQGdQZ2BncGeAZ5BnoGewZ8Bn0GfgZ/BoAGgQaCBoMGhAaFBoYGhwaIBokGigaLBowGjQaOBo8GkAaRBpIGkwaUBpUGlgaXBpgGmQaaBpsGnAadBp4GnwagBqEGogajBqQGpQamBqcGqAapBqoGqwasBq0GrgavBrAGsQayBrMGtAa1BrYGtwa4BrkGuga7BrwGvQa+Br8GwAbBBsIGwwbEBsUGxgbHBsgGyQbKBssGzAbNBs4GzwbQBtEG0gbTBtQG1QbWBtcG2AbZBtoG2wbcBt0G3gbfBuAG4QbiBuMG5AblBuYG5wboBukG6gbrBuwG7QbuBu8G8AbxBvIG8wb0BvUG9gb3BvgG+Qb6BvsG/Ab9Bv4G/wcABwEHAgcDBwQHBQcGBwcHCAcJBwoHCwcMBw0HDgcPBxAHEQcSBxMHFAcVBxYHFwcYBxkHGgcbBxwHHQceBx8HIAchByIHIwckByUHJgcnBygHKQcqBysHLActBy4HLwcwBzEHMgczBzQHNQc2BzcHOAc5BzoHOwc8Bz0HPgc/B0AHQQdCB0MHRAdFB0YHRwdIB0kHSgdLB0wHTQdOB08HUAdRB1IHUwdUB1UHVgdXB1gHWQdaB1sHXAddB14HXwdgB2EHYgdjB2QHZQdmB2cHaAdpB2oHawdsB20HbgdvB3AHcQdyB3MHdAd1B3YHdwd4B3kHegd7B3wHfQd+B38HgAeBB4IHgweEB4UHhgeHB4gHiQeKB4sHjAeNB44HjweQB5EHkgeTB5QHlQeWB5cHmAeZB5oHmwecB50HngefB6AHoQeiB6MHpAelB6YHpweoB6kHqgerB6wHrQeuB68HsAexB7IHswe0B7UHtge3B7gHuQe6B7sHvAe9B74HvwfAB8EHwgfDB8QHxQfGB8cHyAfJB8oHywfMB80HzgfPB9AH0QfSB9MH1AfVB9YH1wfYB9kH2gfbB9wH3QfeB98H4AfhB+IH4wfkB+UH5gfnB+gH6QfqB+sH7AftB+4H7wfwB/EH8gfzB/QH9Qf2B/cH+Af5B/oH+wf8B/0H/gf/CAAIAQgCCAMIBAgFCAYIBwgICAkICggLCAwIDQgOCA8IEAgRCBIIEwgUCBUIFggXCBgIGQgaCBsIHAgdCB4IHwggCCEIIggjCCQIJQgmCCcIKAgpCCoIKwgsCC0ILggvCDAIMQgyCDMINAg1CDYINwg4CDkIOgg7CDwIPQg+CD8IQAhBCEIIQwhECEUIRghHCEgISQhKCEsg+wy3+iS3AfcQt/kstwP3EPoEFf58+YT6fAf9WP4nFfnSB/fF/DMFprAV+8X4NwX49gamYhX90gf7xfgzBXBmFffF/DcF/PYGDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OAAEBAQr4HwwmmhwZLRL7joscBUaLBr0KvQv65xUD6AB8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA==");}', 0);
  
    const check_str = async function(fontname,str){
      let escaped_fontname = fontname
      if (!check_font_list_f.includes(fontname)){
        escaped_fontname = '"' + fontname.replace(/"/g, '"') + '"';
      }
      const chkobj = document.createElement('span');
      chkobj.innerHTML = str;
      chkobj.style.height = 0
      chkobj.style.overflow = 'hidden'
      chkobj.style.position = 'absolute'
      chkobj.style.visibility = 'hidden'
      chkobj.style.fontSize = '72px';
      chkobj.style.fontFamily = escaped_fontname + ',' + f;
      document.body.appendChild(chkobj);
      return await document.fonts.load("72px '" + fontname + "','" + f + "'")
      .then(function (fontset){
        var ok = chkobj.offsetWidth > 1;
        document.body.removeChild(chkobj);
        return ok;
      }).catch(function (err){
        document.body.removeChild(chkobj);
        return false;
      })
    };
    const check = async function(name) {
      if (await check_str(name,check_code)){
        const ret = { name, lang: {} };
        for (let lang of Object.keys(check_codepoint)) {
          ret.lang[lang] = false;
          if (await check_str(name,check_codepoint[lang])) {
            ret.lang[lang] = true;
          }
        }
        return ret;
      } else {
        return null;
      }
    };
    const ret = [];
    const target = check_font_list.concat(check_font_list_f);
    for (let fontname of target) {
      const d = await check(fontname);
      if (d) ret.push(d);
    }
    document.head.removeChild(style);
    var ev = new CustomEvent('fontfamily_list-loaded', {detail: ret});
    window.dispatchEvent(ev);
  }
  document.addEventListener('DOMContentLoaded',function(){
    check_font();
  });
})();



Object.assign(app.modules.utils.vendor.fonts,self);

return self;
}).call({},self);

Object.assign(app.modules.utils.vendor,self);

return self;
}).call({},self);

Object.assign(app.modules.utils,self);

return self;
}).call({},self);

app.modules.browser = {};

const module_browser = self.module_browser = (function(){
  const self = this.self = this;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".browser";
// ================================================
// module: browser , from: clipcache.js
// ================================================

// ================================================
// module: browser , from: layer.js
// ================================================
const Layer = self.Layer = class Layer {
  static OverlapType = {
    SourceOver:"source-over",
    SourceIn:"source-in",
    SourceOut:"source-out",
    SourceAtop:"source-atop",
    DestinationOver:"destination-over",
    DestinationIn:"destination-in",
    DestinationOut:"destination-out",
    DestinationAtop:"destination-atop",
    Lighter:"lighter",
    Copy:"copy",
    Xor:"xor",
    Multiply:"multiply",
    Screen:"screen",
    Overlay:"overlay",
    Darken:"darken",
    Lighten:"lighten",
    ColorDodge:"color-dodge",
    ColorBurn:"color-burn",
    HardLight:"hard-light",
    SoftLight:"soft-light",
    Difference:"difference",
    Exclusion:"exclusion",
    Hue:"hue",
    Saturation:"saturation",
    Color:"color",
    Luminosity:"luminosity",
  };

  static LinkedLayerType = {
    Window: 'window',
    Size: 'size',
    Pos: 'pos',
    Move: 'move',
    CanvasSize: 'canvasSize',
  };

  static DoMethodType = {
    Execute: 0,
    FileLoad: 1,
    CanvasPosChange: 2,
    CanvasSizeChange: 3,
    CanvasAlphaChange: 4,
    CanvasOverlapChange: 5,
    OutputPosChange: 6,
    OutputSizeChange: 7,
    OutputAlphaChange: 8,
    OutputOverlapChange: 9,
  };

  static layerId = 0;

  constructor(main, copyFromLayer){
    this.main = main;
    Layer.layerId += 1;
    this.id = Layer.layerId;
    let x = 0;
    let y = 0;
    let w = this.main.defaultLayer.width;
    let h = this.main.defaultLayer.height;
    if (copyFromLayer != null){
      x = copyFromLayer.canvas.x;
      y = copyFromLayer.canvas.y;
      w = copyFromLayer.canvas.w;
      h = copyFromLayer.canvas.h;
    }
    this.canvasOpt = {
      x: x,
      y: y,
      w: w,
      h: h,
      alpha: 1,
      overlap: Layer.OverlapType.SourceOver,
    };
    let ox = 0;
    let oy = 0;
    let ow = this.main.defaultLayer.width;
    let oh = this.main.defaultLayer.height;
    if (copyFromLayer != null){
      ox = copyFromLayer.outputRect.x;
      oy = copyFromLayer.outputRect.y;
      ow = copyFromLayer.outputRect.w;
      oh = copyFromLayer.outputRect.h;
    }
    this.outputOpt = {
      x: ox,
      y: oy,
      w: ow,
      h: oh,
      alpha: 1,
      overlap: Layer.OverlapType.SourceOver,
    };
    this.canvasCacheRect = {
      x: 0,
      y: 0,
      w: 0,
      h: 0,
    }
    this.parentLayers = [];
    this.childLayers = [];
    this.linkedLayers = {
      window: [],
      size: [],
      pos: [],
      move: [],
      canvasSize: [],
    }
    this.defaultExternalColor = [255,255,255,0]
    this.history = [];
    this.historyPos = -1;
    this.historyMax = -1;
    this.updated = false;
    this.canvasUpdated = false;
    this.canvasCacheUpdated = false;
    this.canvasObj = this.main.window.document.createElement('canvas');
    this.canvasObj.id = 'tie_' + this.main.tieName + '_layer_' + this.id + '_canvas';
    this.canvasObj.width = this.canvasOpt.w;
    this.canvasObj.height = this.canvasOpt.h;
    this.canvasBackupObj = this.main.window.document.createElement('canvas');
    this.canvasBackupObj.id = 'tie_' + this.main.tieName + '_layer_' + this.id + '_canvasBackup';
    this.canvasCacheObj = this.main.window.document.createElement('canvas');
    this.canvasCacheObj.id = 'tie_' + this.main.tieName + '_layer_' + this.id + '_canvasCache';
    this.fill(this.canvasObj,[255,255,255,0]);
  }
  addParentLayer(layer){
    this.parentLayers.push(layer);
    this.updated = true;
  }
  removeParentLayer(layer){
    this.parentLayers = this.parentLayers.filter((v) => v !== layer);
    this.updated = true;
  }
  addChildLayer(layer){
    this.childLayers.push(layer);
    this.updated = true;
  }
  removeChildLayer(layer){
    this.childLayers = this.childLayers.filter((v) => v !== layer);
    this.updated = true;
  }
  addLinkedLayer(layer, type){
    if (type === Layer.LinkedLayerType.Window){
      this.linkedLayers.window.push(layer);
    }else if (type === Layer.LinkedLayerType.Size){
      this.linkedLayers.size.push(layer);
    }else if (type === Layer.LinkedLayerType.Pos){
      this.linkedLayers.pos.push(layer);
    }else if (type === Layer.LinkedLayerType.Move){
      this.linkedLayers.move.push(layer);
    }else if (type === Layer.LinkedLayerType.CanvasSize){
      this.linkedLayers.canvasSize.push(layer);
    }
  }
  removeLinkedLayer(layer, type){
    if (type === Layer.LinkedLayerType.Window){
      this.linkedLayers.window = this.linkedLayers.window.filter((v) => v !== layer);
    }else if (type === Layer.LinkedLayerType.Size){
      this.linkedLayers.size = this.linkedLayers.size.filter((v) => v !== layer);
    }else if (type === Layer.LinkedLayerType.Pos){
      this.linkedLayers.pos = this.linkedLayers.pos.filter((v) => v !== layer);
    }else if (type === Layer.LinkedLayerType.Move){
      this.linkedLayers.move = this.linkedLayers.move.filter((v) => v !== layer);
    }else if (type === Layer.LinkedLayerType.CanvasSize){
      this.linkedLayers.canvasSize = this.linkedLayers.canvasSize.filter((v) => v !== layer);
    }
  }
  setExternalColor(color){
    this.defaultExternalColor = color;
    this.updated = true;
  }
  getExternalColor(){
    return this.defaultExternalColor;
  }
  loadLocalImage(){
    const input = this.main.window.document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = (e) => {
      let file = null;
      if (e.target.files){
        file = e.target.files[0];
      }else if (e.dataTransfer.files){
        file = e.dataTransfer.files[0];
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const context = this.canvasObj.getContext('2d');
          const h = {
            type: Layer.DoMethodType.FileLoad,
            image: structuredClone(context.getImageData(0,0,this.canvasObj.width,this.canvasObj.height).data),
            size:{
              w: this.canvasObj.width,
              h: this.canvasObj.height,
            },
            loadFile: file,
            loadImage: null,
            loadSize:{
              w: img.width,
              h: img.height,
            },
          };
          this.canvasObj.width = img.width;
          this.canvasObj.height = img.height;
          this.canvasOpt.w = img.width;
          this.canvasOpt.h = img.height;
          const ga = context.globalAlpha;
          const gcom = context.globalCompositeOperation;
          context.globalAlpha = 1;
          context.globalCompositeOperation = Layer.OverlapType.Copy;
          context.drawImage(img,0,0);
          context.globalAlpha = ga;
          context.globalCompositeOperation = gcom;
          h.loadImage = structuredClone(context.getImageData(0,0,this.canvasObj.width,this.canvasObj.height).data);
          this.pushHistory(h);
          this.updated = true;
          this.canvasUpdated = true;
          this.doWrite();
        };
        img.onerror = () => {
          alert('ERROR\nnot image file')
        }
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    };
    input.click();
  }
  pushHistory(h){
    if (this.historyMax != 0){
      this.history.push(h);
    }
    while (this.historyPos >= 0 && this.historyPop >= this.history.length - 1){
      this.historyPop();
    }
    this.historyPos = this.history.length - 1;  
    if (this.historyMax >= 0){
      while (this.history.length > this.historyMax){
        this.historyUnshift();
      }
    }
  }
  colorRGBA2Array(color){
    if (color === null || color === undefined){
      return [255,255,255,0];
    }else if (color instanceof Array){
      if (color.length == 3){
        color.push(1);
      }
      return color.map((v) => parseInt(v));
    }else if (typeof color === 'string'){
      if (color.startsWith('rgba(')){
        color = color.replace('rgba(','').replace(')','');
      }else if (color.startsWith('rgb(')){
        color = color.replace('rgb(','').replace(')',',1');
      }else{
        return [255,255,255,0];
      }
      const c = color.split(',');
      if (c.length == 3){
        c.push(1);
      }
      return c.map((v) => parseInt(v));
    }else{
      return [255,255,255,0];
    }
  }
  fillRect(canvas,x,y,w,h,color){
    const context = canvas.getContext('2d');
    const cary = this.colorRGBA2Array(color);
    const contextimg = context.getImageData(x,y,w,h);
    for(let i = 0; i < contextimg.data.length; i += 4){
      contextimg.data[i] = cary[0];
      contextimg.data[i + 1] = cary[1];
      contextimg.data[i + 2] = cary[2];
      contextimg.data[i + 3] = cary[3];
    }
    context.putImageData(contextimg,x,y);
  }
  fill(canvas,color){
    this.fillRect(canvas,0,0,canvas.width,canvas.height,color);
  }
  setCanvasPos(x,y,callers){
    const crect = this.getCanvasRect();
    if (crect.x == x && crect.y == y){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.CanvasPosChange,
      pos:{
        x: this.canvasOpt.x,
        y: this.canvasOpt.y,
      },
    });
    this.canvasOpt.x = x;
    this.canvasOpt.y = y;
    this.updated = true;
    const xdiff = crect.x - x;
    const ydiff = crect.y - y;
    let nextcallers = [];
    if (callers !== null && callers !== undefined){
      if (callers.indexOf(this.id) >= 0){
        return;
      }
      nextcallers = structuredClone(callers);
    }
    nextcallers.push(this.id);
    for(let l of this.linkedLayers.pos){
      const lrect = l.getCanvasRect();
      l.setCanvasPos(lrect.x - xdiff,lrect.y - ydiff,nextcallers);
    }
    for (let l of this.linkedLayers.move){
      const lrect = l.getCanvasRect();
      l.setCanvasPos(lrect.x - xdiff,lrect.y - ydiff,nextcallers);
      const lorect = l.getOutputRect();
      l.setOutputPos(lorect.x - xdiff,lorect.y - ydiff, nextcallers);
    }
  }
  setCanvasSize(w,h,callers){
    const crect = this.getCanvasRect();
    if (crect.w == w && crect.h == h){
      return;
    }
    // copy
    if (w > 0 && h > 0){
      const canvas = this.main.window.document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      this.fill(canvas,[255,255,255,0]);
      if (this.canvasObj.width > 0 && this.canvasObj.height > 0){
        const thiscontext = this.canvasObj.getContext('2d');
        const thisimg = thiscontext.getImageData(0,0,this.canvasObj.width,this.canvasObj.width);
        const context = canvas.getContext('2d');
        context.putImageData(thisimg,0,0,0,0,this.canvasObj.width,this.canvasObj.height);
        this.pushHistory({
          type: Layer.DoMethodType.CanvasSizeChange,
          image: structuredClone(thisimg.data),
          size:{
            w: this.canvasObj.width,
            h: this.canvasObj.height,
          },
        });
        const nextimg = context.getImageData(0,0,w,h);
        this.canvasObj.width = w;
        this.canvasObj.height = h;
        thiscontext.putImageData(nextimg,0,0);
        this.canvasOpt.w = w;
        this.canvasOpt.h = h;
      }else{
        this.pushHistory({
          type: Layer.DoMethodType.CanvasSizeChange,
          image: null,
          size:{
            w: this.canvasObj.width,
            h: this.canvasObj.height,
          },
        });  
        this.canvasObj.width = w;
        this.canvasObj.height = h;
        this.canvasOpt.w = w;
        this.canvasOpt.h = h;
      }
    } else {
      const thiscontext = this.canvasObj.getContext('2d');
      const thisimg = thiscontext.getImageData(0,0,this.canvasObj.width,this.canvasObj.width);
      this.pushHistory({
        type: Layer.DoMethodType.CanvasSizeChange,
        image: structuredClone(thisimg.data),
        size:{
          w: this.canvasObj.width,
          h: this.canvasObj.height,
        },
      });
      w = h = 0;
      this.canvasObj.width = w;
      this.canvasObj.height = h;
      this.canvasOpt.w = w;
      this.canvasOpt.h = h;
    }
    this.updated = true;
    let nextcallers = [];
    if (callers !== null && callers !== undefined){
      if (callers.indexOf(this.id) >= 0){
        return;
      }
      nextcallers = structuredClone(callers);
    }
    nextcallers.push(this.id);
    for(let l of this.linkedLayers.canvasSize){
      l.setCanvasSize(w,h,nextcallers);
    }
  }
  getCanvasRect(){
    return {
      x: this.canvasOpt.x,
      y: this.canvasOpt.y,
      w: this.canvasOpt.w,
      h: this.canvasOpt.h,
    };
  }
  setCanvasAlpha(alpha){
    if (this.canvasOpt.alpha == alpha){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.CanvasAlphaChange,
      alpha: this.canvasOpt.alpha,
    });
    this.canvasOpt.alpha = alpha;
    this.updated = true;
  }
  getCanvasAlpha(){
    return this.canvasOpt.alpha;
  }
  setCanvasOverlapMode(mode){
    if (this.canvasOpt.overlap == mode){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.CanvasOverlapChange,
      overlap: this.canvasOpt.overlap,
    });
    this.canvasOpt.overlap = mode;
    this.updated = true;
  }
  getCanvasOverlapMode(){
    return this.canvasOpt.overlap;
  }
  setOutputPos(x,y,callers){
    const crect = this.getOutputRect();
    if (crect.x == x && crect.y == y){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.OutputPosChange,
      pos:{
        x: this.outputOpt.x,
        y: this.outputOpt.y,
      },
    });
    this.outputOpt.x = x;
    this.outputOpt.y = y;
    this.updated = true;
    const xdiff = crect.x - x;
    const ydiff = crect.y - y;
    let nextcallers = [];
    if (callers !== null && callers !== undefined){
      if (callers.indexOf(this.id) >= 0){
        return;
      }
      nextcallers = structuredClone(callers);
    }
    nextcallers.push(this.id);
    for(let l of this.linkedLayers.window){
      const lrect = l.getOutputRect();
      l.setOutputPos(lrect.x - xdiff,lrect.y - ydiff,nextcallers);
    }
    for(let l of this.linkedLayers.move){
      const lrect = l.getCanvasRect();
      l.setCanvasPos(lrect.x - xdiff,lrect.y - ydiff,nextcallers);
      const lorect = l.getOutputRect();
      l.setOutputPos(lorect.x - xdiff,lorect.y - ydiff,nextcallers);
    }
  }
  setOutputSize(w,h,callers){
    const crect = this.getOutputRect();
    if (crect.w == w && crect.h == h){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.OutputSizeChange,
      size:{ 
        w: this.outputOpt.w,
        h: this.outputOpt.h,
      }
    });
    this.outputOpt.w = w;
    this.outputOpt.h = h;
    this.updated = true;
    if (callers !== null && callers !== undefined){
      if (callers.indexOf(this) >= 0){
        return;
      }
    }
    let nextcallers = [];
    if (callers !== null && callers !== undefined){
      if (callers.indexOf(this.id) >= 0){
        return;
      }
      nextcallers = structuredClone(callers);
    }
    nextcallers.push(this.id);
    for(let l of this.linkedLayers.size){
      const lrect = l.getOutputRect();
      l.setOutputPos(lrect.x - xdiff,lrecy.y - ydiff, nextcallers);
    }
  }
  getOutputRect(){
    return {
      x: this.outputOpt.x,
      y: this.outputOpt.y,
      w: this.outputOpt.w,
      h: this.outputOpt.h,
    };
  }
  setOutputAlpha(alpha){
    if (this.outputOpt.alpha == alpha){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.OutputAlphaChange,
      alpha: this.outputOpt.alpha,
    });
    this.outputOpt.alpha = alpha;
    this.updated = true;
  }
  getOutputAlpha(){
    return this.outputOpt.alpha;
  }
  setOutputOverlapMode(mode){
    if (this.outputOpt.overlap == mode){
      return;
    }
    this.pushHistory({
      type: Layer.DoMethodType.OutputOverlapChange,
      overlap: this.outputOpt.overlap,
    });
    this.outputOpt.overlap = mode;
    this.updated = true;
  }
  getOutputOverlapMode(){
    return this.outputOpt.overlap;
  }
  calcCacheRect(){
    let x = this.canvasOpt.x;
    let y = this.canvasOpt.y;
    let w = this.canvasOpt.w - this.canvasOpt.x;
    let h = this.canvasOpt.h - this.canvasOpt.y;
    if (this.outputOpt.x < x){
      x = this.outputOpt.x;
    }
    if (this.outputOpt.y < y){
      y = this.outputOpt.y;
    }
    if (this.outputOpt.w - this.outputOpt.x > w){
      w = this.outputOpt.w - this.outputOpt.x;
    }
    if (this.outputOpt.h - this.outputOpt.y > h){
      h = this.outputOpt.h - this.outputOpt.y;
    }
    for(let c of this.childLayers){
      const r = c.calcCacheRect();
      if (r.x < x){
        x = r.x;
      }
      if (r.y < y){
        y = r.y;
      }
      if (r.w - r.x > w){
        w = r.w - r.x;
      }
      if (r.h - r.y > h){
        h = r.h - r.y;
      }
    }
    if (w < 0){
      w = 1;
    }
    if (h < 0){
      h = 1;
    }
    return {
      x: x,
      y: y,
      w: w,
      h: h,
    };
  }
  doWriteCanvas2Canvas(srcCanvasObj,destCanvasObj,srcCanvasOpt,destCanvasRect){
    if (srcCanvasObj.width <= 0 || srcCanvasObj.height <= 0){
      return;
    }
    if (destCanvasObj.width <= 0 || destCanvasObj.height <= 0){
      return;
    }
    if (srcCanvasOpt.w <= 0 || srcCanvasOpt.h <= 0){
      return;
    }
    if (destCanvasRect.w <= 0 || destCanvasRect.h <= 0){
      return;
    }
    const context = destCanvasObj.getContext('2d');
    context.globalAlpha = srcCanvasOpt.alpha;
    context.globalCompositeOperation = srcCanvasOpt.overlap;
    let srcX = srcCanvasOpt.x;
    let srcY = srcCanvasOpt.y;
    let srcW = srcCanvasObj.width;
    let srcH = srcCanvasObj.height;
    let destX = (destCanvasRect.x);
    let destY = (destCanvasRect.y);
    let destW = srcCanvasObj.width;
    let destH = srcCanvasObj.height;
    console.log(srcCanvasObj,destCanvasObj)
    console.log(srcCanvasOpt,destCanvasRect,srcX,srcY,srcW,srcH,destX,destY,destW,destH);
    //if (destX != 0){
      try{ throw new Error(''); }catch(e){ console.log(e.stack); }
    //}
    context.drawImage(srcCanvasObj,srcX,srcY,srcW,srcH,destX,destY,destW,destH);
  }
  parentCacheClear(){
    for(let p of this.parentLayers){
      if (p instanceof Layer){
        p.fill(p.canvasCacheObj,p.defaultExternalColor);
        p.canvasCacheUpdated = true;
        p.parentCacheClear();
      }else if (p instanceof HTMLCanvasElement){
        this.fill(p,this.defaultExternalColor);
      }
    }
  }

  initCanvasCache(force){
    let updated = false;
    let canvasCacheRect = this.calcCacheRect();
    if (canvasCacheRect.x != this.canvasCacheRect.x ||
        canvasCacheRect.y != this.canvasCacheRect.y ||
        canvasCacheRect.w != this.canvasCacheRect.w ||
        canvasCacheRect.h != this.canvasCacheRect.h){
      this.canvasCacheRect = canvasCacheRect;
      this.canvasCacheObj.width = canvasCacheRect.w;
      this.canvasCacheObj.height = canvasCacheRect.h;
      updated = true;
      this.canvasCacheUpdated = true;
    }
    if (force == true || this.updated == true || this.canvasUpdated == true){
      this.canvasCacheUpdated = true;
    }
    if (this.updated == true || this.canvasUpdated == true){
      updated = true;
    }
    for(let c of this.childLayers){
      if (c instanceof Layer){
        if(c.initCanvasCache(force) == true){
          updated = true;
        }
      }else if (c instanceof HTMLCanvasElement){
        updated = true;
      }
    }
    if (force == true || updated == true){
      this.fill(this.canvasCacheObj,this.defaultExternalColor);
      this.canvasCacheUpdated = true;
      updated = true;
    }
    return updated;
  }
  checkCanvasUpdated(){
    if (this.updated == true || this.canvasUpdated == true){
      return true;
    }
    for(let c of this.childLayers){
      if (c instanceof Layer){
        if (c.checkCanvasUpdated() == true){
          return true;
        }else if (c instanceof HTMLCanvasElement){
          return true;
        }
      }
    }
    return false;
  }
  checkCanvasCacheUpdated(){
    if (this.canvasCacheUpdated == true){
      return true;
    }
    for(let c of this.childLayers){
      if (c instanceof Layer){
        if (c.checkCanvasCacheUpdated() == true){
          return true;
        }else if (c instanceof HTMLCanvasElement){
          return true;
        }
      }
    }
    return false;
  }
  doWriteChildLayers2Cache(force){
    let updated = false;
    if (this.updated == true || this.canvasUpdated == true){
      this.updated = false;
      this.canvasUpdated = false;
      updated = true;
    }
    const copyopt = structuredClone(this.canvasCacheRect);
    copyopt.x = 0;
    copyopt.y = 0;
    for(let c of this.childLayers){
      if (c instanceof Layer){
        let cupdated = false;
        if (force == true || c.checkCanvasUpdated() == true || this.checkCanvasCacheUpdated() == true){
          cupdated = c.doWriteCanvas2Cache(force);
          c.updated = false;
          c.canvasUpdated = false;
          c.canvasCacheUpdated = true;
        }
        if (cupdated == true || c.canvasCacheUpdated == true){
          this.doWriteCanvas2Canvas(c.canvasCacheObj,this.canvasCacheObj,c.outputOpt,copyopt);
          c.canvasCacheUpdated = false;
          updated = true;
        }
      }else if (c instanceof HTMLCanvasElement){
        this.doWriteCanvas2Canvas(c,this.canvasCache,{x:0,y:0,w:c.width,h:c.height,alpha:1,overlap:Layer.OverlapType.SourceOut},copyopt);
        updated = true;
      }
    }
    if (updated == true){
      this.canvasCacheUpdated = true;
    }
    return updated;
  }
  doWriteCanvas2Cache(force){
    let updated = this.doWriteChildLayers2Cache(force);
    if (force || updated == true || this.updated == true || this.canvasUpdated == true || this.canvasCacheUpdated == true){
      const copyopt = structuredClone(this.canvasOpt);
      copyopt.x = 0;
      copyopt.y = 0;
      this.doWriteCanvas2Canvas(this.canvasObj,this.canvasCacheObj,copyopt,this.canvasOpt);
      this.updated = false;
      this.canvasUpdated = false;
      this.canvasCacheUpdated = true;
      updated = true;
    }
    return updated;
  }
  getTopParentLayers(){
    let layers = [];
    if (this.parentLayers.length == 0){
      return [this.canvasObj];
    }
    for(let p of this.parentLayers){
      if (p instanceof Layer){
        layers = layers.concat(p.getTopParentLayers());
      }else if (p instanceof HTMLCanvasElement){
        layers.push(this);
      }
    }
    return layers;
  }
  doWriteCanvasCache2CanvasElement(force){
    let updated = false;
    for(let p of this.parentLayers){
      if (p instanceof Layer){
        // do nothing
      }else if (p instanceof HTMLCanvasElement){
        this.doWriteCanvas2Canvas(this.canvasCacheObj,p,{x:0,y:0,w:this.canvasCacheObj.width,h:this.canvasCacheObj.height,alpha:1,overlap:Layer.OverlapType.SourceOver},{x:0,y:0,w:p.width,h:p.height});
        updated = true;
      }
    }
    return updated;
  }
  doWrite(force){
    let updated = false;
    const initUpdate = this.initCanvasCache(force);
    if (initUpdate == true || this.canvasCacheUpdated == true){
      this.parentCacheClear();
    }
    for(let tlayer of this.getTopParentLayers()){
      if (tlayer instanceof Layer){
        if (tlayer.doWriteCanvas2Cache(force) == true){
          tlayer.doWriteCanvasCache2CanvasElement(force);
          updated = true;
        }
      }else if (tlayer instanceof HTMLCanvasElement){
        // do nothing
      }
    }
    return updated;
  }

  saveBackup(){
    this.canvasBackupObj.width = this.canvasObj.width;
    this.canvasBackupObj.height = this.canvasObj.height;
    const context = this.canvasObj.getContext('2d');
    const contextBackup = this.canvasBackupObj.getContext('2d');
    const img = context.getImageData(0,0,this.canvasObj.width,this.canvasObj.height);
    contextBackup.putImageData(img,0,0);
  }
  restoreBackup(){
    this.canvasObj.width = this.canvasBackupObj.width;
    this.canvasObj.height = this.canvasBackupObj.height;
    const context = this.canvasObj.getContext('2d');
    const contextBackup = this.canvasBackupObj.getContext('2d');
    const img = contextBackup.getImageData(0,0,this.canvasObj.width,this.canvasObj.height);
    context.putImageData(img,0,0);
    this.canvasUpdated = true;
  }
  doMethod(method, opt){
    if (method === null || method === undefined) return null;
    const context = this.canvasObj.getContext('2d');
    this.pushHistory({
      type: Layer.DoMethodType.Execute,
      method,
      opt: structuredClone(opt),
      image: structuredClone(context.getImageData(0,0,this.canvasObj.width,this.canvasObj.height).data),
      imageOpt: structuredClone(this.canvasOpt),
    });
    const r = method(this.canvasObj,opt);
    this.canvasUpdated = true;
    //this.doWrite();
  }
  setHistoryMax(v){
    this.historyMax = v;
    if (this.historyMax >= 0){
      while (this.history.length > this.historyMax){
        this.historyUnshift();
      }
    }
  }
  historyClear(){
    this.history = [];
    this.historyPos = -1;
  }
  historyDepth(){
    return this.history.length;
  }
  historyCurrent(){
    return this.historyPos;
  }
  historyUnshift(){
    if (this.history.length <= 1){
      this.history = [];
      this.historyPos = -1;
      return;
    }
    if (this.historyPos <= 0){
      return;
    }
    this.history.unshift();
    this.historyPos -= 1;
  }
  historyPop(){
    if (this.history.length <= 1){
      this.history = [];
      this.historyPos = -1;
      return;
    }
    if (this.historyPos >= this.history.length - 1){
      return;
    }
    this.history.pop();
  }
  doHistory(h){
    // TODO
    this.doWrite();
  }
  historyBack(){
    if (this.history.length < 1){
      return;
    }
    if (this.historyPos == -1){
      this.historyPos = this.history.length - 1;
      this.doHistory(this.history[this.historyPos]);
    }else{
      if (this.historyPos <= 0){
        return;
      }
      this.doHistory(this.history[this.historyPos]);
      this.historyPos -= 1;
    }
  }
  historyForward(){
    if (this.history.length < 1){
      return;
    }
    if (this.historyPos > this.history.length - 1){
      this.historyPos = this.history.length - 1;
    }
    if (this.historyPos == -1){
      return;
    }
    this.historyPos += 1;
    if (this.historyPos > this.history.length - 1){
      this.historyPos = -1;
    }
    if (this.historyPos == -1){
      return;
    }
    this.doHistory(this.history[this.historyPos]);
  }
}

// ================================================
// module: browser , from: Storage.js
// ================================================
// storage class
const Storage = self.Storage = class Storage {
  constructor(main,g_window) {
    this.main = main;
    this.g_window = g_window;
  }
  #realKeyPrefixName(){
    return APP_ID + "_" + this.main.tieName + "_";
  }
  #realKeyName(key) {
    return this.#realKeyPrefixName() + key;
  }
  save(key, value) {
    this.g_window.localStorage.setItem(this.#realKeyName(key),JSON.stringify(value));
  }
  load(key, defaultValue) {
    if (defaultValue === undefined) defaultValue = null;
    const v = this.g_window.localStorage.getItem(this.#realKeyName(key));
    if (v === null) return defaultValue;
    try{
      return JSON.parse(v);
    }catch(e){
      console.log(e);
      return defaultValue;
    }
  }
  delete(key) {
    this.g_window.localStorage.removeItem(this.#realKeyName(key));  
  }
  keys(prefix) {
    const r = [];
    const gprefx = this.#realKeyPrefixName();
    if (prefix === undefined || prefix === null) prefix = '';
    for (let i = 0; i < this.g_window.localStorage.length; i++) {
      const name = this.g_window.localStorage.key(i);
      if (name !== '') {
        if (name.startsWith(gprefx)) {
          const n = name.substring(gprefx.length);
          if (n.startsWith(prefix)){
            r.push(n.substring(prefix.length));
          }
        }
      } 
    }
    return r;
  }
  clear(prefix) {
    if (prefix === undefined || prefix == null) prefix = '';
    for(let k of this.keys(prefix)) {
      this.delete(k);
    }
  }
  clearAllStorageData(){
    this.g_window.localStorage.clear();
  }
}


Object.assign(app.modules.browser,self);

return self;
}).call({},self);

app.modules.canvasMethod = {};

const module_canvasMethod = self.module_canvasMethod = (function(){
  const self = this.self = this;
  const __MODULE_PARENT__ = self.__MODULE_PARENT__ = arguments[0] || null;
  const __MODULE_NAME__ = self.__MODULE_NAME__ = app.APP_ID + ".canvasMethod";
// ================================================
// module: canvasMethod , from: copy.js
// ================================================
const copy = self.copy = function copy(canvas, opt) {
  const option = {
    
  };
}

// ================================================
// module: canvasMethod , from: fillClearPattern.js
// ================================================
const fillClearPattern = self.fillClearPattern = function fillClearPattern(canvas, opt) {
  const context = canvas.getContext('2d');
  // fill white
  context.fillStyle = 'rgba(255, 255, 255, 1)';
  context.fillRect(0, 0, canvas.width, canvas.height);
  const len = 32;
  for(let x=0;x<canvas.width;x+=len){
    for(let y=0;y<canvas.height;y+=len){
      // clear pattern
      context.fillStyle = 'rgba(224, 224, 224, 1)';
      context.beginPath();
      context.moveTo(x+len/2,y);
      context.lineTo(x+len,y+len/2);
      context.lineTo(x+len/2,y+len);
      context.lineTo(x,y+len/2);
      context.closePath();
      context.fill();
    }
  }
}


Object.assign(app.modules.canvasMethod,self);

return self;
}).call({},self);

// ================================================
// source: Main.js
// ================================================
// Main (export) class
const Main = self.Main = class Main {
  constructor(targetObj, tieName, bodyObj) {
    this.$tie = Main.$tie;
    this.window = app.g_window;
    this.targetObj = targetObj;
    if (tieName === undefined || tieName === null) {
      tieName = 'default';
    }
    this.tieName = tieName;
    if (bodyObj === undefined || bodyObj === null){
      bodyObj = app.g_window.document.getElementsByTagName("body")[0];
    }
    this.bodyObj = bodyObj;
    this.storage = new modules.browser.Storage(this,this.window);
    this.history = {
      maxdepth: -1,
    };
    this.baseCanvas = this.window.document.createElement("canvas");
    this.baseCanvas.width = this.targetObj.getBoundingClientRect().width;
    this.baseCanvas.height = this.targetObj.getBoundingClientRect().height;
    this.defaultLayer = {
      bgcolor: "rgba(255,255,255,1)",
      fgcolor: "rgba(0,0,0,1)",
      externalColor: "rgba(0,216,216,1)",
      width: this.baseCanvas.width,
      height: this.baseCanvas.height,
    };
    this.targetObj.appendChild(this.baseCanvas);

    this.viewerLayer = new modules.browser.Layer(this);
    this.viewerLayer.setHistoryMax(0);
    this.viewerLayer.setExternalColor(this.defaultLayer.externalColor);
    this.viewerLayer.setCanvasSize(0,0);
    this.viewerLayer.addParentLayer(this.baseCanvas);

    this.clearpatternLayer = new modules.browser.Layer(this);
    this.clearpatternLayer.setHistoryMax(0);
    this.clearpatternLayer.addParentLayer(this.viewerLayer);
    this.viewerLayer.addChildLayer(this.clearpatternLayer);
    //this.clearpatternLayer.addLinkedLayer(this.viewerLayer,modules.browser.Layer.LinkedLayerType.CanvasSize);
    //this.viewerLayer.addLinkedLayer(this.clearpatternLayer,modules.browser.Layer.LinkedLayerType.CanvasSize);

    this.baseLayer = new modules.browser.Layer(this);
    this.baseLayer.setHistoryMax(0);
    this.baseLayer.addParentLayer(this.viewerLayer);
    this.viewerLayer.addChildLayer(this.baseLayer);
    this.baseLayer.addLinkedLayer(this.viewerLayer,modules.browser.Layer.LinkedLayerType.CanvasSize);
    this.viewerLayer.addLinkedLayer(this.baseLayer,modules.browser.Layer.LinkedLayerType.CanvasSize);
    this.baseLayer.addLinkedLayer(this.clearpatternLayer,modules.browser.Layer.LinkedLayerType.Move);
    this.clearpatternLayer.addLinkedLayer(this.baseLayer,modules.browser.Layer.LinkedLayerType.Move);

    this.layer = new modules.browser.Layer(this);
    this.baseLayer.addChildLayer(this.layer);
    this.layer.addParentLayer(this.baseLayer);
    this.baseLayer.addLinkedLayer(this.layer,modules.browser.Layer.LinkedLayerType.Move);
    this.layer.addLinkedLayer(this.baseLayer,modules.browser.Layer.LinkedLayerType.Move);

    this.layer2 = new modules.browser.Layer(this);
    this.baseLayer.addChildLayer(this.layer2);
    this.layer2.addParentLayer(this.baseLayer);
    this.baseLayer.addLinkedLayer(this.layer2,modules.browser.Layer.LinkedLayerType.Move);
    this.layer2.addLinkedLayer(this.baseLayer,modules.browser.Layer.LinkedLayerType.Move);

    this.clearpatternLayer.doMethod(modules.canvasMethod.fillClearPattern,null);
    this.viewerLayer.doWrite();
    this.window.addEventListener("DOMContentLoaded", () =>{
      const ovserver = new ResizeObserver(() => {
        this.baseCanvas.width = this.targetObj.getBoundingClientRect().width;
        this.baseCanvas.height = this.targetObj.getBoundingClientRect().height;
        this.viewerLayer.setCanvasSize(this.baseCanvas.width, this.baseCanvas.height);
        this.viewerLayer.setOutputPos(0,0);
        this.viewerLayer.setOutputSize(0,0);
        const cacheRect = this.viewerLayer.calcCacheRect();
        this.viewerLayer.setCanvasSize(0,0);
        this.viewerLayer.setOutputPos(cacheRect.x,cacheRect.y);
        this.viewerLayer.setOutputSize(cacheRect.w,cacheRect.h);
        //this.viewerLayer.setOutputSize(this.baseCanvas.width, this.baseCanvas.height);
        this.clearpatternLayer.doMethod(modules.canvasMethod.fillClearPattern,null);
        this.viewerLayer.doWrite();
      });
      ovserver.observe(this.targetObj);
    });
  }
  static $tie = $tie;
}

return Main;
}).call({},{});
